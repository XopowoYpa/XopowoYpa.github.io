---
title: Leetcode3.无重复字符的最长子串
date: 2022-06-29 17:01:19 +/-TTTT
categories: [计算机技术, 算法]
tag: [滑动窗口, 双指针]
---

## 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

提示：
0 <= s.length <= 5 * 10e4
s 由英文字母、数字、符号和空格组成

> 题目链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/

## 题解
暴力解法用双重循环加哈希表就可以实现，时间复杂度是n²的，空间复杂度为n。

滑动窗口的解法需要维护一个区间以及哈希表也可以实现，这个区间里的字符串不能重复，一重循环枚举每个滑动窗口的左端点，然后再加一重循环搜索不重复的子串的右端点位置，最后作差就可以得到答案，右端点是具有单调性的，所以第二重循环最多也只会循环n次，总体时间复杂度和空间复杂度和本文的解法一致。

本文使用数组模拟哈希表以及双指针的算法，j表示以i为结尾的不重复字符串的起点位置，用i遍历整个字符串，数组中存储的是每个字符的最后一次出现的位置，由于子串是连续的，j必然是递增的，如果j递减或者不变无法保证子串是不重复的，如果遇到重复字符那么j只能取重复字符的后一个位置才能保证最长，同时也要保证j的单调性，每次遇到重复的字符更新一下j的值来保证j指向的起点是不重复子串的起点。

### 代码：
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.empty()) return 0;

        // 数组均初始化为-1
        int hs[128];
        memset(hs, -1, sizeof(hs));

        int ans = 1;
        for(int i = 0, j = 0; i < s.size(); i ++){
            int idx = s[i] - ' ';
            // 遇到重复字符的情况，第二个条件保证了j单调
            if(hs[idx] != -1 && j <= hs[idx] + 1){
                j = hs[idx] + 1;
            }
            // 更新每个字符最后一次出现的下标
            hs[idx] = i;
            ans = max(ans, i - j + 1);
        }

        return ans;
    }
};
```
### 分析：
时间复杂度O(n)，空间复杂度O(S)，S表示字符集的大小，标准ASCII码的大小S为128。
