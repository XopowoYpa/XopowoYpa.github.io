[ { "title": "Linux网络编程", "url": "/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/", "categories": "计算机技术, Linux", "tags": "C++, Linux, socket, I/O模型, I/O多路复用", "date": "2022-08-08 20:37:31 +0800", "snippet": "引言本文主要介绍了Linux环境下的网络编程，主要使用到了socket、select、poll、epoll等API，并且给出相关介绍与使用样例。字节序字节序是大于一个字节类型的数据在内存中存放的顺序，字节序分为大端字节序和小端字节序（小端存储和大端存储），大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。举例：假设有数据0x 01 02 03 04（4个字节），同时假设内存地址增长方向是从左往右的，那么如果按照小端存储则有：0x04 03 02 01按照大端存储则有：0x01 02 03 04判断机器是大端还是小端：union{\tshort v; // 2个字节 char bytes[sizeof(v)]; // char[2] 2个字节} test;test.v = 0x0102;if((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) cout &lt;&lt; \"大端存储\" &lt;&lt; endl;else if((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1))cout &lt;&lt; \"小端存储\" &lt;&lt; endl;字节序转换 API如果格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端会错误解释数据。解决的办法是：发送端总是以大端序发送数据，接收端根据自己的情况将大端序转换为自己需要的字节序。TCP/IP中规定了一种数据表示格式，即大端序，从而保证数据在不同主机之间传输可以被正确解释。Socket提供了封装好的转换API：#include&lt;arpa/inet.h&gt;// h表示 host，n表示network，s表示unsigned short，l表示unsigned int// 转换端口用uint16_t htons(uint16_t hostshort); // 主机字节序转网络字节序，返回值是大端的uint16_t ntohs(uint16_t netshort);\t// 反之，返回值根据主机而定// 转换ip用uint32_t htonl(uint32_t hostlong); // 主机字节序转网络字节序，返回值是大端的uint32_t ntohl(uint32_t netlong); // 反之，返回值根据主机而定IP地址转换 API通常我们喜欢用可读性好的字符串来表示ip地址，比如127.0.0.1，实际上在机器中存储的是一个无符号整型，把它用来表示地址，因此需要互相转换，具体API如下（比较旧的API）：#include&lt;arpa/inet.h&gt;typedef unsigned int in_addr_t;struct in_addr{ in_addr_t s_addr;};// 十进制形式ipv4地址字符串cp转换为ipv4网络字节序的数并返回in_addr_t inet_addr(const char *cp); // 十进制形式ipv4地址字符串cp，转换为ipv4网络字节序列的地址inp// 返回1表示转换成功，0表示输入非法int inet_aton(const char* cp, struct in_addr *inp); // ipv4网络字节序地址转换为十进制形式ipv4地址字符串char *inet_ntoa(struct in_addr_in)最新的API（ipv4和ipv6都可以使用）：#include&lt;arpa/inet.h&gt;// 命名中p表示十进制IP字符串，n表示netaddr即网络字节序的整数/* 参数说明af - 表示协议类型（af：AF_INET、AF_INET6）src - 表示十进制形式IP地址dst - 表示转换完成后的网络字节序整数返回值 - 1表示转换成功，0表示输入非法，-1表示协议非法*/int inet_pton(int af, const char *src, void *dst);// 反过程，size表示可用的字节数的大小，即表示dst的size// 返回值表示转换后的字符串的地址，和dst是相同值const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);socket APIsocket提供了一套网络的API，用户可以通过socket来传输数据。通用socket地址里面封装了第一层的接口，专用socket地址封装了第二层的接口，用户主要是通过专用socket接口来使用socket。通用socket地址socket地址为一个结构体，其定义如下：#include&lt;sys/socket.h&gt;typedef unsigned short int sa_family_t;// ipv4使用struct sockaddr{ sa_family_t sa_family; char sa_data[4];};// ipv6使用struct sockaddr_storage{ sa_family_t sa_family; unsigned long int __ss_align; // 字节对齐用 char __ss_padding[128 - sizeof(__ss_align)];};sa_family成员是地址族类型（sa_family_t）的变量，地址族与协议族类型相对应，两者实际存储的值都是相同的，因此可以混用，常见的协议族和地址族如下： 协议族 地址族 描述 地址值含义 长度 PF_UNIX AF_UNIX Unix本地域协议族 文件的路径名 最长108字节 PF_INET AF_INET TCP/IPv4协议族 16位的端口号以及32位的ipv4地址 6字节 PF_INET6 AF_INET6 TCP/IPv6协议族 16位的端口号、32位流标识、128位的ipv6地址 26字节 专用socket地址由于很多网络编程函数都是基于ipv4的，那时候使用的都是通用socket地址，为了兼容，现在的通用socket地址退化成了类似于void *的作用，专用socket地址使用sockaddr_in或者sockaddr_in6，那么只需要给API传入sockaddr_in或者sockaddr_in6即可，函数内部会自动把专用的地址类型转化为通用地址类型。# define __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int))#include&lt;netinet/in.h&gt;typedef unsigned int in_addr_t;typedef unsigned short in_port_t;struct in_addr{ in_addr_t s_addr;};struct sockaddr_in{ sa_family_t sin_family; // 地址族 in_port_t sin_port;\t// 端口 struct in_addr sin_addr; // 地址 unsigned char sin_zero[sizeof(struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof(in_port_t) - sizeof(struct in_addr)]; // 填充};struct sockaddr_in6{ sa_family_t sin6_family; in_port_t sin6_port; uint32_t sin6_flow_info; // ipv6的flow table struct in6_addr sin6_addr; // 类似于in_addr uint32_t sin6_scope_id; // ipv6的scope id};常用API#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt; // 该头文件包含了上面两个头文件/* 参数说明domain - 表示协议族有：AF_INET、AF_INET6、AF_UNIX等type - 表示通信过程中的协议类型，常见的有：SOCK_STREAM（流式协议）、SOCK_DGRAM（报式协议）等protocol - 表示具体的协议，一般传入0，比方说对于SOCK_STREAM填0就表示默认使用TCP，对于SOCK_DGRAM填0表示默认使用UDP返回值 - 为文件描述符(fd)，如果失败则返回-1*/int socket(int domain, int type, int protocol); // 创建套接字/* 参数说明sockfd - 表示通过socket函数得到的fdsockaddr - 表示需要绑定的地址和端口addrlen - 表示addr占用的内存大小返回值 - 成功0，失败-1*/int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 将fd与本地的IP和port进行绑定/* 参数说明sockfd - 同上backlog - 表示未连接队列和已经连接队列和的最大值，如果超过这个最大值则放弃连接，已连接表示已经经过3次握手的，未连接表示还没完成3次握手，一般设置成5就可以*/int listen(int sockfd, int backlog); // 监听有socket上有无客户端连接/* 参数说明sockfd - 同上sockaddr - 记录了连接成功后客户端的地址信息addrlen - 表示addr占用的内存大小（注意是以指针传递）返回值 - 成功返回用于通信的fd（不同于监听连接的fd），失败返回-1*/int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // 接收客户端连接/* 参数说明sockfd - 表示客户端用于通信的fdaddr - 表示客户端要连接的服务端的地址信息addrlen - 表示addr占用的内存大小返回值 - 成功0，失败-1*/int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 客户端连接服务器ssize_t write(int fd, const void *buf, size_t count); // 写数据sszie_t read(int fd, void *buf, size_t count);\t// 读数据简单TCP服务端样例#include&lt;iostream&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#include&lt;cstring&gt;using namespace std;int main(){ // 1. 创建socket int lsnfd = socket(AF_INET, SOCK_STREAM, 0); // 使用ipv4和TCP协议创建socket if(lsnfd == -1){ // 意外处理 perror(\"socket create failed\"); return -1; } // 2. 绑定socket sockaddr_in saddr; // 创建专用socket地址 saddr.sin_family = AF_INET; // 或者使用PF_INET，都表示使用ipv4协议 saddr.sin_addr.s_addr = 0; // ip地址设置为本机（0.0.0.0）,或者使用INADDR_ANY来绑定所有网卡的ip地址 // 如果要使用指定IP地址则应该使用以下代码，将本机字节序转换为网络字节序 // inet_pton(AF_INET, \"127.0.0.1\", &amp;saddr.sin_addr_s_addr); saddr.sin_port = htons(9999); // 设置socket端口号为9999，并转换为网络字节序 int rt = bind(lsnfd, (sockaddr *)&amp;saddr, sizeof(saddr)); // 绑定 if(rt == -1){ // 意外处理 perror(\"bind failed\"); return -1; } // 3. 监听 rt = listen(lsnfd, 8); // 监听创建的socket，并且把两个监听队列的总和上限设置为8 if(rt == -1){ // 意外处理 perror(\"listen failed\"); return -1; } // 4. 接受客户端的连接 sockaddr_in cliaddr; // 用于接收客户端的地址信息 socklen_t sz = sizeof(cliaddr); int clifd = accept(lsnfd, (sockaddr *)&amp;cliaddr, &amp;sz); // 阻塞的，直到有客户端连接进来 if(clifd == -1){ // 意外处理 perror(\"accept from client failed\"); return -1; } // 5. 读取客户端地址信息 char cliip[16]; // IP地址字符串的最长字节数为16（4个大小为3字节的数字、3个1字节的点、1个字节的字符串结尾\\0） inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliip, sizeof(cliip)); // 将客户端收到的IP地址（网络字节序）转为本机字节序 unsigned short cliport = ntohs(cliaddr.sin_port); // 接收客户端的端口（网络字节序），并且转换为本机字节序 cout &lt;&lt; \"[Server] Accept a clinet connection which from \" &lt;&lt; cliip &lt;&lt; \":\" &lt;&lt; cliport &lt;&lt; endl; // 输出客户端地址和端口 // 6. 读取客户端的数据 char recvbuf[1024]; // 创建缓存 memset(recvbuf, 0, sizeof(recvbuf)); int len = read(clifd, recvbuf, sizeof(recvbuf)); // 从accept到的客户端fd读取数据 if(len == -1){ // 意外处理 perror(\"read failed\"); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; \"[Server] Receive a message from client (\" &lt;&lt; cliip &lt;&lt; \":\" &lt;&lt; cliport &lt;&lt; \") : \" &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; \"[Server] client (\" &lt;&lt; cliip &lt;&lt; \":\" &lt;&lt; cliport &lt;&lt; \") disconnect\" &lt;&lt; endl; } // 7. 给客户端返回数据 char msg[] = \"server has received your message\"; rt = write(clifd, msg, sizeof(msg)); // 8. 关闭文件描述符（只通信一次就退出） close(clifd); close(lsnfd); return 0;}简单TCP客户端样例#include&lt;iostream&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#include&lt;cstring&gt;using namespace std;int main(){ // 1. 创建socket int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1){ perror(\"create socket failed\"); return -1; } // 2. 连接服务器 sockaddr_in saddr; saddr.sin_family = AF_INET; inet_pton(AF_INET, \"192.168.85.128\", &amp;saddr.sin_addr.s_addr); // 设置服务器ip地址 saddr.sin_port = htons(9999); // 设置服务器端口 int rt = connect(fd, (sockaddr*)&amp;saddr, sizeof(saddr)); if(rt == -1){ perror(\"connect failed\"); return -1; } // 3. 给服务器发送数据 char msg[] = \"Hello!\"; write(fd, msg, sizeof(msg)); // 4. 读取服务器返回的数据 char recvbuf[1024]; memset(recvbuf, 0, sizeof(recvbuf)); int len = read(fd, recvbuf, sizeof(recvbuf)); if(len == -1){ // 意外处理 perror(\"read failed\"); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; \"[Client] Receive a message from server : \" &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; \"[Client] Server closed\" &lt;&lt; endl; } // 5. 关闭文件描述符 close(fd); return 0;}I/O多路复用I/O多路复用又称I/O多路转接，I/O多路复用可以让程序同时监听多个文件描述符(file descriptor)，从而提高程序的性能。Linux下实现I/O多路复用的API有select、poll和epoll。常见的I/O模型有： 阻塞IO模型（Blocking I/O, BIO） 程序阻塞等待数据，有数据就去处理，没数据就在等待。 优点：不占用CPU的时间片 缺点：同一时刻只能处理一个，效率低 如果有多个数据需要处理，那么就要通过多进程或者多线程的方式来处理。 缺点：创建线程或者进程调度占用内存资源，线程或者进程的调度占用CPU资源 非阻塞IO模型（Non-blocking I/O, NIO） 程序不阻塞等待数据，但是需要轮询（会使用到系统调用），每隔一小段时间去查询是否有数据进来，有就去处理。如果需要处理的数据有很多，即有多个客户端连接到服务器，那么轮询会大量消耗系统资源。 优点：提高程序的执行效率 缺点：需要占用更多CPU和系统资源 IO多路复用模型 I/O多路复用则是把查询交给了内核去做，让内核通知用户，有什么数据需要处理。I/O多路复用实现有select、poll和epoll，简单来说select和poll只通知有数据到达了，但是不知道是哪些数据到达了，需要用户去轮询，epoll则会告知哪些数据到达了，用户直接去读取即可。 信号驱动IO模型 信号驱动不再使用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（使用系统调用sigaction来发出SIGIO信号），然后用户可以去做别的事，不用阻塞。当内核数据准备好后，再通过SIGIO信号通知用户，然后用户再去读数据。 异步IO模型（Asynchronous I/O, AIO） 前面的模型每当有数据需要读取时，都会发生数据读取时产生的阻塞，因为用户需要从内核空间拷贝到用户空间，因此都不是异步I/O。异步I/O模型实现了IO全流程的非阻塞，用户发出系统调用后，直接返回去处理自己的事情，等内核数据准备好，将数据拷贝到用户空间，发送信号通知用户IO操作执行完毕。 I/O多路复用 APIselectselect API select使用流程： 调用select，监听列表中的文件描述符，直到列表中一个文件描述符或者多个文件描述符进行I/O操作时，select才返回（select是阻塞的，对文件描述符的操作是由内核完成的） 返回时，select会告诉有多少文件描述符需要操作 select工作流程：（结合API）fd_set会从用户空间拷贝到内核空间，然后遍历fd_set的每个标志位来判断是否要监听，如果有文件描述符变化了，那么会把更改过后的fd_set再拷贝到用户空间，用户也需要遍历fd_set的每个标志位来判断是否要操作数据。#include&lt;sys/time.h&gt;#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;/* fd_settypedef long int __fd_mask;struct fd_set{\t__fd_mask __fds_bits[__FD_SETSIZE / _NFDBITS];};sizeof(fd_set) = 128 // 占用了1024位*//*timevalstruct timeval{ long tv_sec; // 秒 long tv_usec; // 微秒};*//* 参数说明nfds - 委托内核检测的最大文件描述符的值再加上1readfds - 委托内核检测文件描述符是否有读操作的集合（检测读缓冲区有没有数据）,fd_set类型可以看成是一个很大的整数，里面每一位（标志位）都表示一个fd，0表示不需要检测的fd，1表示需要检测的fd，由于是个指针，这个参数也会返回内核检测到的可以读取的fd的信息（可以读标志位为1，否则为0）writefds - 委托内核文件描述符是否有写操作的集合（检测写缓冲区是否满了，满了标志位为0，没满标志位为1）exceptfds - 检测发生异常的文件描述符的集合 timeout - 设置超时时间，值为NULL为永久阻塞直到检测fd有变化，值为0表示不阻塞直接返回，值大于0表示阻塞对应时间返回值 - -1表示失败, 大于等于0表示检测的集合中有对应的文件描述符发生了变化*/int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);// 将set中fd对应的标志位，置为0void FD_CLR(int fd, fd_set *set);// 判断set中fd对应的标志位是0还是1并返回int FD_ISSET(int fd, fd_set *set);// 将set中fd对应的标志位，置为1void FD_SET(int fd, fd_set *set);// 将set中所有标志位全部初始化为0voif FD_ZERO(fd_set *set);select使用样例// int lfd = socket(...);// ...// bind(...);// listen(...);// 创建fd_set，存储需要检测文件描述符fd_set rdset, tmp; // 因为内核会更改fd_set，因此可以把tmp交给内核修改，然后使用rdset复原即可FD_ZERO(&amp;rdset); // 初始化为0FD_SET(lfd, &amp;rdset); // 把监听fd设置为1int maxfd = lfd; // 初始化最大的fdwhile(1){ tmp = rdset; int rt = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); // 阻塞到有数据进来（或者说是有客户端连接） if(rt == -1){ // 意外处理 perror(\"select failed\"); exit(-1); }\t else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(FD_ISSET(lfd, &amp;tmp)){ // 判断lfd是否有数据可操作（或者说是有客户端连接） // int cfd = accept(...); FD_SET(cfd, &amp;rdset); // 将新的fd加入集合中 maxfd = max(maxfd, cfd); // 更新最大的fd } } for(int i = lfd + 1; i &lt;= maxfd; i ++){ // 轮询rdset，lfd是第一个创建的fd所以初始值可以直接赋为lfd + 1 if(FD_ISSET(i, &amp;tmp)){ // 判断fd是否有数据来了\t\t\tchar buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(i, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(\"read failed\"); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; \"client closed\" &lt;&lt; endl; FD_CLR(i, &amp;rdset); } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } }以上的例子可以看到并没有使用到多线程和多进程就可以处理多个客户端的数据。select 的缺陷 每次都需要把fd_set从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历fd_set的每个标志位，时间复杂度是O(n)的。 select支持的文件描述符数量太小了，只有1024个。 fd_set不能重用，每次都需要重置。pollpoll API#include&lt;poll.h&gt;struct pollfd{ int fd; // 委托内核检测的文件描述符 short events; // 委托内核检测fd的什么事件（用户设置的变量） short revents; // fd实际发生的事件（内核操作的变量）};/* 参数介绍fds - 是一个pollfd的结构体数组指针，这是一个需要检测的fd的集合nfds - 表示pollfd结构体数组中最后一个有效元素的下标加1timeout - 阻塞时长，-1表示阻塞（直到fds有变化），0表示不阻塞，大于0表示阻塞对应的时长(ms)返回值 - -1表示失败，大于等于0表示成功，表示有对应个fd发生变化*/int poll(struct pollfd *fds, nfds_t nfds, int timeout);pollfd中的events和revents的取值有： 事件 值 作为events的值 作为revents的值 说明 读事件 POLLINPOLLRDNORMPOLLRDBANDPOLLPRI √√√√ √√√√ 普通或优先带数据可读普通数据可读优先级带数据可读高优先级数据可读 写事件 POLLOUTPOLLWRNORMPOLLWRBAND √√√ √√√ 普通或优先带数据可写普通数据可写优先级带数据可写 错误事件 POLLERRPOLLHUPPOLLNVAL   √√√ 发生错误发生挂起描述不是打开的文件 比较常用的读事件的值为POLLIN，写事件的值为POLLOUT，如果既要检测读事件也要检测写事件可以写成POLLIN | POLLOUT。poll使用样例// int lfd = socket(...);// ...// bind(...);// listen(...);const int FDSIZE = 1024;pollfd fds[FDSIZE]; // 数组大小可以任意指定，不一定是1024for(int i = 0; i &lt; FDSIZE; i ++){ // 初始化pollfd结构体数组 fds[i].fd = -1; fds[i].events = POLLIN;}fds[0].fd = lfd; // 监听fd加入数组中int nfds = 0; // 记录有效fd的最大下标，为了方便实现直接记录数组的最大下标即可while(1){ int rt = poll(fds, nfds + 1, -1); // 阻塞，等待数据进来（或等待客户端连接） if(rt == -1){ // 意外处理 perror(\"poll failed\"); exit(-1); }\t else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(fds[0].revents &amp; POLLIN){ // 表示监听文件描述符lfd的revents中存在POLLIN事件（位运算） // int cfd = accept(...); // 找pollfd数组中空闲位置插入新加入的fd（有新的客户端连接） for(int i = 1; i &lt; FDSIZE; i ++){ if(i &gt; nfds) nfds = i; // 记录最大下标（不一定是有效） if(fds[i].fd == -1){ fds[i].fd = cfd; fds[i].events = POLLIN; break; } } } } for(int i = 1; i &lt;= nfds; i ++){ // 轮询fds，0是监听fd，因此需要从1开始遍历 if(fds[i].revents &amp; POLLIN){ // 判断fds元素的revents中是否存在POLLIN事件（位运算）\t\t\tchar buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(fds[i].fd, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(\"read failed\"); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; \"client closed\" &lt;&lt; endl; close(fds[i].fd); // 关闭对应fd fds[i].fd = -1; // 将pollfd数组对应元素的fd置为-1，空出位置 } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } }poll的缺陷 需要把pollfd数组从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历pollfd数组的每个revents来判断是否有数据变化，时间复杂度是O(n)的。epollepoll API#include&lt;sys/epoll.h&gt;/* struct eventpoll{\t//...\tstruct rb_root rbr; // 红黑树根节点，红黑树中存储需要检测的文件描述符\tstruct list_head rdlist; // 就绪队列双链表，存储有数据变化的文件描述符\t// ...};*//* 参数说明size - 目前没有意义了，随便写一个大于0的数返回值 - 失败返回-1，成功返回文件描述符fd，用于操控内核空间中的实例(eventpoll类型)*/int epoll_create(int size); // 在内核空间中创建实例(eventpoll类型)typedef union epoll_data{ void *ptr; int fd; uint32_t u32; uint64_t u64;} epoll_data_t; strut epoll_event{ uint32_t events; // 需要检测的epoll事件（EPOLL_IN、EPOLLOUT、EPOLLERR、EPOLLET等） epoll_data_t data; // 存储用户的数据信息，一般只存fd};/* 参数介绍epfd - 通过epoll_create创建出来的eventpoll实例对应的fdop - 对eventpoll实例的操作选项，比如添加fd、删除fd、修改fd检测的操作等（分别对应EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD）fd - 需要进行操作的文件描述符event - 记录了fd需要检测的事件（删除操作输入NULL即可）返回值 - 成功返回0，失败返回-1*/int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 操作内核空间的eventpoll实例/* 参数介绍epfd - 同上events - 存储所有发生了变化的fdmaxevents - events数组的大小timeout - 阻塞时间，-1表示阻塞（直到有fd发生变化），0表示不阻塞，大于表示要阻塞的时长(ms)返回值 - 成功返回发生变化的fd的个数，失败返回-1*/int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // 检测是否有发生变化的fd，从内核空间的就绪队列中拷贝出来，存储在events中epoll的两种工作模式水平触发（Level Triggered, LT）LT是默认的工作方式，同时支持阻塞和非阻塞的socket，在这种工作模式中，内核会不断通知用户是否有文件描述符就绪了，然后用户可以对就绪的文件描述符进行IO操作，如果用户没有进行操作的话，内核还是会继续通知用户。边缘触发（Edge Triggered, ET）ET是较为高速的工作方式，只支持非阻塞的socket，当有文件描述符变成就绪时，内核只会通知用户一次（only once），后续不会为这个文件描述符向用户发送就绪通知，直到用户操作了文件描述符使得这个文件描述符不再是就绪状态。 比如有个fd就绪了有8个字节需要读取，用户只读取了2个字节，剩余6个字节没有读取，在下次内核发现这个fd里面还有数据没读的话，在ET模式下内核就不会再通知用户（直到又有新数据到来了，更改了该fd的就绪状态，但是也是会按照缓冲区的顺序读取数据），在LT模式下内核就会去通知用户。 ET模式减少了内核通知用户的次数，因此效率比LT模式要高，但是epoll在ET模式的时候，必须使用非阻塞的套接字接口，因为内核只通知用户一次，用户应该一次把数据读完，所以就不能使用阻塞的读写操作，否则就会导致进程或者线程饿死（因为需要阻塞等待数据的读或者写）。epoll使用案例LT模式// int lfd = socket(...);// ...// bind(...);// listen(...);int epfd = epoll_create(100); // 创建eventpoll实例，参数随便写个大于0的数// 将监听fd添加到eventpoll实例中epoll_event epev;epev.events = EPOLLIN;epev.data.fd = lfd;epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);const int FDSIZE = 1024;epoll_event epevs[FDSIZE]; // 接收从内核检测到的fd集合，大小无限制while(1){\t // 阻塞等待数据来（或等客户端连接） // 返回值是发生变化fd的数目 // 由于是水平触发，如果数据没有读完，epoll_wait会把没有读完的fd放入就绪队列中再返回 int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ // 失败处理 perror(\"epoll wait failed\"); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd;\t\t if(curfd == lfd){ // 判断是否是监听fd，如果为真说明有客户端连接 // ... // int cfd = accept(...); // 将接收到的客户端fd加入内核检测的fd集合中 epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ // 说明是客户端fd，判断是读操作的情况\t\t\tchar buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ // 错误处理 perror(\"cfd read failed\"); exit(-1); } else if(len == 0){ // 客户端关闭连接 cout &lt;&lt; \"client closed\" &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); //从eventpoll实例中删除该fd close(curfd); } else if(len &gt; 0){ // 读到数据了进行对应处理 cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } } else if(epevs[i].events &amp; EPOLLOUT){ //客户端fd写操作的情况 // 写操作逻辑 } } }\t// 关闭创建出来的lfd和epfdclose(lfd);close(epfd);ET模式相比于LT模式，ET需要多更改一些设置，代码如下：// int lfd = socket(...);// ...// bind(...);// listen(...);int epfd = epoll_create(100); epoll_event epev;epev.events = EPOLLIN; // 监听fd应该为水平触发epev.data.fd = lfd;epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);const int FDSIZE = 1024;epoll_event epevs[FDSIZE]; while(1){\t // 由于是边缘触发，内核只通知一次 // 如果数据没读完，那么后面的数据就无法读到（需要一次性读完） int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ perror(\"epoll wait failed\"); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd;\t\t if(curfd == lfd){ // ... // int cfd = accept(...); // 设置cfd为非阻塞，以用于后续非阻塞读写 // 头文件需要额外添加fcntl.h int flag = fcntl(cfd, F_GETFL); // 得到cfd的flag fcntl(cfd, F_SETFL, flag | O_NONBLOCK); // 设置flag为非阻塞 // 设置为边缘触发 // // --------------------------------// epev.events = EPOLLIN | EPOLLET; // --------------------------------// epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ /* 无法一次性读取数据\t\t\tchar buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ perror(\"cfd read failed\"); exit(-1); } else if(len == 0){ cout &lt;&lt; \"client closed\" &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); } else if(len &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } */ // 一次性读取所有数据，使用循环来分别读取出来 char buf[1024]; memset(buf, 0, sizeof(bug)); int len = 0; while( (len = read(curfd, buf, sizeof(buf))) &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // 读操作逻辑 // write(...) } if(len == 0){\t\t\t\tcout &lt;&lt; \"clinet closed\" &lt;&lt; endl; } else if(len == -1){ // 需要额外头文件errno.h if(errno == EAGAIN){ // 数据读完可能产生的错误 // 处理逻辑 } else{ perror(\"read failed\"); \texit(-1); } } } else if(epevs[i].events &amp; EPOLLOUT){ // 写操作逻辑 } } }close(lfd);close(epfd);参考资料[1]. 牛客网——C++高薪面试项目[2]. 掘金——看一遍就理解：IO模型详解" }, { "title": "C++编程工具（Linux）", "url": "/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/", "categories": "计算机技术, C++", "tags": "C++, Linux, GCC, 静态库, 动态库, Makefile, GDB, CMake", "date": "2022-07-28 01:34:10 +0800", "snippet": "引言本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。本文持续更新中GCCGCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要介绍GCC在C/C++上的编译应用。GCC的工作流程graph LR\tA([源代码]) --&gt; B[预处理器]\tB --&gt; C([预处理后源代码])\tC --&gt; D[编译器]\tD --&gt; E([汇编代码])\tE --&gt; F[汇编器]\tF --&gt; G2\tG1([启动代码]) --&gt; H\tG2([目标代码]) --&gt; H\tG3([库代码]) --&gt; H\tG4([其他目标代码]) --&gt; H\tH[链接器] --&gt; I([可执行程序])\t 图中的源代码一般是.c、.h、.cpp文件。 首先经过预处理器后得到.i文件，预处理器的作用是展开头文件、宏替换、删除注释等。 其次经过编译器把.i文件中的代码转换为汇编代码.s文件，编译器的作用则是将预处理后源代码编译成汇编代码。 随后通过汇编器将汇编代码.i文件转换为目标代码.o文件（机器代码），汇编器的作用则是将汇编代码转换为二进制指令。 最后将不同的.o文件链接成一个可执行程序.exe（windows）或者.out（linux）文件即可，链接器的作用则是链接各种代码形成可执行程序。GCC常用参数 GCC参数选项 作用 -E 预处理指定文件 -S 编译指定文件（包括了预处理，但是不会进行汇编） -c 编译、汇编指定文件（不进行链接） -o [app] [src][src] -o [app] 将文件src编译成可执行文件app -I [directory] i大写，指定#include包含的搜索目录（静态库需要使用） -g 在编译时候生成调试信息（GDB需要使用） -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -O0/O1/O2/O3 编译器优化的4个级别，O0表示没有优化，O1为缺省值，O3优化级别最高 -l 小写L，指定编译时候，所要包含的库（静态库需要使用） -L 库的搜索路径（静态库需要使用） -fPIC/fpic 生成与位置无关的代码（动态库需要使用） -shared 生成共享目标文件（建立共享库或称动态库） -std 指定C语言的编译标准，如有-std=c99 使用样例：gcc test.c -E -o test.i # test.cpp -&gt; test.i（预处理代码）gcc test.i -S -o test.s # test.i -&gt; test.s（汇编代码）gcc test.s -c -o test.o # test.s -&gt; test.o（机器代码/二进制文件）gcc test.c -o app # test.cpp -&gt; app（可执行程序）# -I 参数在静态库的样例中查看# -g 参数在GDB的样例中查看# 定义了一个DEBUG宏，如果代码中存在宏的条件编译# 如#ifdef DEBUG ... #else ... #endif，则会判断是否定义了DEBUG# 定义了则会编译#ifdef中的内容，否则是else的内容gcc test.c -o test -D DEBUG gcc test.c -o test -w # 不生生成任何的warning，比如定义的变量没有使用等gcc test.c -o -Wall # 生成所有的warninggcc test.c -o test -O3 # 对程序进行“臭氧”优化# -l 参数在静态库的样例中查看# -L 参数在静态库的样例中查看# -fPIC/fpic 参数在动态库的样例中查看# -shared 参数在动态库的样例中查看g++ test.cpp -o test -std=c++11静态库静态库是指在程序的链接阶段被复制到目标程序当中的库。静态库的优点： 静态库被打包到到应用程序中加载速度快 发布程序无需提供静态库，移植方便静态库的缺点： 消耗系统资源，浪费内存（如果有多个程序使用了此静态库，则静态库会被编译多次） 更新、部署、发布麻烦（如果更新了静态库，则需要重新编译使用了此静态库的源代码）静态库的制作 命名规则：Linux系统中命名格式为libxxx.a（lib和.a固定，xxx是库的名称），Windows系统中格式则是libxxx.lib 通过gcc获得.o文件 使用ar工具将.o文件打包，命令如下：ar rcs libxxx.a file1.o file2.o # xxx.o ... 参数rcs分别表示： r —— 往备存文件（或称库文件）中插入.o文件 c —— 建立备存文件（或称库文件） s —— 生成.o文件的索引制作样例：# 假设有以下文件：#-add.c#-div.c#-head.h#-main.c#-mult.c#-sub.cgcc -c add.c div.c mult.c sub.c # 生成对应的.o文件ar rcs libcalc.a add.o sub.o mult.o div.o # 生成libcalc.a静态库文件静态库的使用# 假设有以下文件：#-include/#\t-head.h#-lib/#\t-libcalc.a#-main.cgcc main.c -o app -I ./include/ -l calc -L ./lib/ # -I表示包含的头文件位置，-l表示包含的库文件名称，-L表示库的搜索目录./app # 执行程序动态库动态库是指在程序编译时不被链接到目标代码中，而是在程序运行时才被载入的库。动态库的优点： 可以实现进程间资源共享（各个应用程序都可以共享载入到内存中的动态库） 更新、部署、发布简单（每次更新只需要重新编译库文件即可） 可以控制何时加载动态库（使用到的时候才会去加载）动态库的缺点： 加载速度比静态库慢 发布程序时需要提供依赖的动态库动态库的制作 命名规则：Linux系统中命名格式为libxxx.so（lib和.so固定，xxx是库的名称），Windows系统中格式则是libxxx.dll 通过gcc得到.o文件，需要得到和位置无关的代码（-fpic/-fPIC） 通过gcc得到动态库制作样例：gcc -c -fpic add.c div.c mult.c sub.c # xxx.c ...gcc -shared *.o -o libcalc.so动态库的使用# 假设有以下文件：#-include/#\t-head.h#-lib/#\t-libcalc.so#-main.cgcc main.c -o main -I include/ -L lib/ -l calc # 编译./main # 执行# 结果输出./main: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory动态库是在程序启动之后动态地加载到内存中，因此需要给定库文件的路径，一般情况下如果没有设定库文件路径，直接编译使用了动态库的源代码会报not found的错误，此时可以通过ldd（list dynamic dependencies）命令检查动态库依赖关系：ldd appLinux系统下的动态库载入需要系统的动态载入器来获取其绝对路径，找到库文件后再将其载入内存即可，对于elf格式的可执行程序是由ld-linux.so来完成的，搜索路径如下所示： elf文件的DT_RPATH段（不常用，用gcc加入链接操作-Wl -rpath指定搜索路径） 环境变量LD_LIBRARY_PATH 通过以下指令： export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库的绝对路径(比如/usr/xxx/mylib/) 来添加，这是一种临时的配置，随着终端的退出就会失效，如果想要永久配置，有两种配置方式： 用户级别的配置 进入/home/用户名/.bashrc文件，在文件末尾添加以上export指令，然后输入source .bashrc来更新配置即可。 系统级别的配置 进入etc/profile文件，在文件末尾添加以上export命令，然后更新配置即可。 /etc/ld.so.cache文件列表 ld.so.cache是一个二进制文件，无法直接修改，需要通过修改同目录下的ld.so.conf文件来完成配置，将路径直接加入到文件，然后使用ldconfig指令来更新配置即可。 /lib/或者/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） /usr/lib/或者/usr/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） 最后编译程序和执行程序就可以正常通过了：gcc main.c -o main -I include/ -L lib/ -l calc # 编译./main # 执行MakefileMakefile文件定义了一系列的规则来指文件的编译顺序，其作用就是为了自动化编译，使用make指令来完全自动的编译。Makefile文件命名和规则 文件命名 makefile或者Makefile命名的文件 Makefile规则 一个Makefile文件可以有一个或者多个规则，其规则模板如下： 目标 ...: 依赖 ...\t命令（shell 命令）\t... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或者目标 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进） Makefile中的其他规则一般都是为第一条规则服务的 GDBCMake参考资料[1]. 牛客网——C++高薪面试项目[2]. CSDN——Linux下动态库(共享库）的制作与使用[3]. 知乎——linux设置程序搜索动态库路径" }, { "title": "C++11 新特性", "url": "/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/", "categories": "计算机技术, C++", "tags": "C++11", "date": "2022-07-27 08:20:01 +0800", "snippet": "引言本文主要介绍C++11中的新特性，汇集了书本以及网络上的博客内容，综合成一本手册供自己查阅使用，本文给出基本的使用方法，如有实现文章则该文章将会以超链接的形式给出，有需要可以点击查阅，所有使用到的资料将在文章结尾给出。本文持续更新中智能指针shared_ptr&lt;T&gt;unique_ptr&lt;T&gt;weak_ptr&lt;T&gt;auto_ptr&lt;T&gt;lambda表达式initializer_list&lt;T&gt;initializer_list&lt;T&gt;是一种模板类型，类似vector&lt;T&gt;，一般可用于传入不定个同类型参数的函数。所属库为&lt;initializer_list&gt;。常用API 函数 作用 - initializer_list&lt;T&gt; list- initializer_list&lt;T&gt; list{a, b, c, …}- initializer_list&lt;T&gt; list2(list)- initializer_list&lt;T&gt; list2 = list - 默认初始化，初始化T类型的空列表- 初始化一个列表，包含花括号内的所有元素- 拷贝构造函数，原始列表和副本共享元素- 拷贝赋值构造函数，原始列表和副本共享元素 list.size() 返回列表元素数量 list.begin() 返回列表首元素的指针 list.end() 返回列表尾元素下个位置的指针 常见使用场景 作为函数的可变参数列表void func(initializer_list&lt;int&gt; il){\t// do something}func({1,2,3,4}); 作为类的列表初始化class A{\tpublic: A(initializer_list&lt;int&gt; il);};A::A(initializer_list&lt;int&gt; il){ // init data}A a = {1,2,3,4,5};A b{1,2,3,4};functionfuture&lt;T&gt;参考资料[1]. 《C++ primer 第五版》[2]." }, { "title": "Redis入门", "url": "/posts/Redis%E5%85%A5%E9%97%A8/", "categories": "计算机技术, Redis", "tags": "Redis, C语言, 数据结构", "date": "2022-07-23 14:29:01 +0800", "snippet": "介绍Redis是基于内存的非关系型数据库，它是使用使用 ANSI C 语言编写的数据库系统，不同于传统磁盘数据库系统，它是一种高性能的key-value存储系统，并且还支持集群、分布式、主从同步等配置，它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。本文主要介绍了Redis的一些实现原理，以及常见的知识点和API。 阅读本文您需要了解：C语言、数据结构、常见算法本文持续更新中…数据结构字符串（string）Redis自己实现了一套字符串结构，即SDS（Simple Dynamic Strings，简单动态字符串），不使用C语言的字符数组，原因是以下三点： 如果想要获取C语言的字符串的值，需要O(n)级别的时间复杂度（即遍历整个字符数组）。 没有比较好的扩容机制，每次扩容都要重新分配空间。 特殊的字符无法处理，因为字符串是以\\0结尾的，如对下面两个例子拼接会出现问题：char *a = \"redis\\0\";char *b = \"mysql\\0\"那么Redis是怎么定义字符串的呢，如下所示：// redis 3.0之前的版本 struct sdshdr{ unsigned int len; unsigned int free; char buf[];}// redis 3.0之后的版本struct sdshdr{ unsigned int len; unsigned int alloc; unsigned char flags; char buf[];}对于第一个版本，len字段表示实际使用到的长度，free字段表示空闲的长度，那么整个分配的总长度就是len + free，buf字段就是实际存储字符串的地方。对于第二个版本，len字段、buf字段与第一个版本相同，alloc字段代表分配的总长度，flags代表SDS（Simple Dynamic Strings，简单动态字符串）的类型，以区别不同长度大小的字符串，如下所示：struct sdsher8{ uint8_t len; uint8_t alloc; unsigned char flags; char buf[];}struct sdshdr16{ uint16_t len; uint16_t alloc; unsigned char flags; char buf[];}// ...以此类推Redis字符串本质上是C语言字符数组的封装，加上一些标识属性而已，从而有以下优点： 字符串获取时间复杂度从O(n)到O(1)。 减少字符串扩容带来的搬运次数。 可以存储更加复杂的二进制数据。 链表（list）Redis的链表是双向链表，结点的结构如下所示：struct listNode{ struct listNode* prev; struct listNode* next; void* value;}prev字段表示前置结点，next字段表示后置结点，value字段表示结点的数值，那么整个链表的定义就如下所示：struct list{ listNode* head; listNode* tail; unsigned long len; void *(*dup) (void* ptr); void (*free) (void* ptr); void (*match)(void* ptr, void* key);}head字段表示链表头结点，tail字段表示链表尾结点，dup字段表示结点复制函数，free字段表示结点释放函数，match字段表示结点值比较函数。链表常见的API有（详细使用方法可以参考官方文档）： 函数 作用 lpush 向链表左边添加元素 rpush 向链表右边增加元素 lpop 弹出左边第一个元素 rpop 弹出右边第一个函数 llen 获得链表长度 lrange 按索引范围获得值 哈希表(hash)Redis采用拉链法作为哈希表的冲突实现，Redis中哈希表的数据结构可以分为： dictht——表示一个哈希表 dictEntry——表示哈希表的一项，可以看做是一个键值对 dict——Redis给外层调用的哈希表结构，包含两个dicthtstruct dictht{ dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;}table字段为哈希表数组（即哈希表项的集合），size字段表示哈希表的大小，used字段表示表中有多少个元素，sizemask字段表示哈希表掩码，如果要访问的位置超出了哈希表的大小，那么可以与哈希表掩码相与，去掉高位的二进制位，比如要访问idx = 1111 1011，sizemask = 0000 1111，那么 idx &amp; sizemask = 0000 1011，这样可以使得要访问的位置不会溢出。将used / size可以得到该哈希表的空闲度也称为负载因子，负载因子越低表示冲突比较少，由于是拉链法，就会使得拉链不会很长，查找效率比较高，负载因子越高表示冲突较多，拉链比较长，查找效率就会比较低。struct dictEntry{ void *key; union{ void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next;}key，v字段表示key-value键值对，next字段表示冲突后拉链的下个结点，next为NULL代表只有一个结点。struct dict{ dictType *type; void *privdata; dictht ht[2]; int rehashidx;}dict是给外界访问用的接口，而不是直接使用dictht，原因是考虑到rehash的情况，rehash就是由于空间的变大或者缩小，需要把老的哈希表元素转移到开辟了新的空间的哈希表上，并进行重新计算。而负载因子就决定了是否rehash，redis要使得负载因子在合理的范围内，因此需要对哈希表进行扩展或者收缩。ht字段中的ht[0]就代表着老的哈希表，ht[1]代表着新的哈希表，如果没有rehash，那么只有h[0]有数据，如果在rehash，那么ht[0]和ht[1]都有数据，执行完rehash之后，ht[0]指向ht[1]，ht[1]指向NULL即可。rehashidx字段为rehash的搬运标识符，如果没有进行rehash那么rehashidx为-1，如果在rehash那么rehashidx代表从老哈希表到新哈希表搬运了多少元素。type字段、privdata字段待更新。什么时候会执行rehash呢？ 如果Redis没有在执行后台备份，当负载因子大于等于1就执行。 如果Redis在执行后台备份，当负载因子大于等于5就执行。集合（Set）普通集合普通集合就是使用哈希表映射实现的。整数集合整数集合是Redis自创的一种集合，它的结构如下所示：struct intset{ uint32_t encoding; uint32_t length; int8_t contents[];}encoding字段表示编码方式，有int16_t、int32_t、int64_t三种范围，为了尽可能地节省内存，它会根据插入数据的大小来选择不同的编码格式。length字段表示集合的长度。contents字段表示元素数组，数组中的成员从小到大依次排列，且不允许重复。那么如何查询数据呢，使用二分法即可，但是查找效率就变成了O(log n)而不是哈希表的O(1)，带来的好处就是可以节省空间。intset的修改查找操作 对于修改，intset保持一段空间有序，由于intset占用一段连续的内存，所以每次修改数据需要重新申请空间，比如增加就是扩容，删除就是缩容。 对于查找，由于intset一段空间有序，使用二分查找即可。有序集合（Zset） 跳表：是一种基于单链表的数据结构，普通单链表查找需要遍历整个链表，因此查找效率是O(n)的，为了降低查找复杂度，参考二叉搜索树，可以建立索引，每两个元素建立一级索引，每两个一级索引建立二级索引。具体结构可以参考跳表的原理与实现 [图解]。Redis的跳表结点结构如下：struct zskiplistNode{ sds ele; // 元素，在热词场景中为一段文字，可以先不了解这个字段 double score; // 权重值，热词情景下就是热度 struct zskiplistNode *backward; struct zskiplistLevel{ struct zskiplistNode *forward; unsigned long span; } level[]; }score字段在普通跳表中就是元素值，backward字段代表后面的结点，level字段表示结点数组，比方说该跳表有二级索引，假设长度是足够长的并且每两个结点建立一个索引，那么第一个结点level的大小就为2，level[0]指向一级索引的下个结点，level[1]指向二级索引的下个结点。第一个结点的下个结点由于不存在索引，所以level数组为空，以此类推。level字段下的span字段表示此结点到下个结点需要跳过的结点数，两个相邻的结点span为1。跳表的问题在于每次插入元素都需要重新建立一次索引，代价比较大，如何解决呢？可以使用概率的方法，每插入一个新元素，有1/2的概率将该元素为无索引，1/4概率为一级索引，1/8的概率为二级索引，以此类推，使用这样的方式建立索引和原方法效率差不多。Redis跳表定义如下：struct zskiplist{ struct zskiplistNode *header, *tail; unsigned long length; int level;}header、tail字段分别表示跳表的头尾，length字段表示跳表的长度，level字段表示最长的索引结点数组的长度。有序集合的常见API（详细使用方法可以参考官方文档）： 函数 作用 zadd 增加元素 zcard 查询zset的元素个数 zrank 获取元素在zset的位置 zcount 获取指定score之间存在的成员个数 zrangebyscore 获取指定score之间存在的元素 zrem 删除元素 zscore 获取指定值的分数 持久化RDBAOF缓存缓存淘汰过期删除缓存一致缓存穿透缓存雪崩集群主从复制哨兵cluster参考资料[1]. BILIBILI——【微软程序员】Redis入门[2]. RUNOOB——Redis教程[3]. 知乎——Redis【入门】就这一篇！[4]. CSDN——聊聊 Redis 为什么构建自己的简单动态字符串 SDS[5]. Redis数据库学习教程（快速入门版）" }, { "title": "Leetcode124.二叉树中的最大路径和", "url": "/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/", "categories": "计算机技术, 算法", "tags": "二叉树", "date": "2022-07-15 21:05:39 +0800", "snippet": "124. 二叉树中的最大路径和路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 。示例 1：输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6示例 2：输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42提示：树中节点数目范围是 [1, 3 * 10e4]-1000 &lt;= Node.val &lt;= 1000 题目链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum题解本题思路大致上可以说是枚举每个结点的最大路径，然后得到全局的最大值。但是要怎么枚举呢，每个结点都有左子树和右子树，设f(node)表示该子树的路径状态，这个路径状态指的是走到当前结点的后续走向是怎么样的，那么路径状态的计算可以表示为f(node) = node -&gt; val + max(0, f(node -&gt; left), f(node -&gt; right))，f(node)的状态计算说明一共有三种情况，即有三种路径走向：第一种是左右树是空的或者是负的路径，那么直接返回node -&gt; val就可以了，即左右子树都不走的情况。第二种是往左子树走，前提是左子树比右子树的路径大。第三种是往左子树走，前提是右子树比左子树的路径大。那么只要计算每个结点，并得到最大值就可以得出答案了，即计算每个结点的f(node) + f(node -&gt; left) + f(node-&gt;right)，取全局最大值即可。代码/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: // 全局最大路径 int ans = INT_MIN;\t// 返回当前结点路径状态f(node) int dfs(TreeNode* node){ if(!node) return 0; int left = max(0, dfs(node -&gt; left)), right = max(0, dfs(node -&gt; right)); // 计算每个结点的路径最大值 ans = max(ans, node -&gt; val + left + right); return node -&gt; val + max(left, right); } int maxPathSum(TreeNode* root) { dfs(root); return ans; }};分析时间复杂度O(n)，空间复杂度O(1 + log n)，递归栈的深度与树的高度相关。" }, { "title": "Leetcode143.重排链表", "url": "/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/", "categories": "计算机技术, 算法", "tags": "链表", "date": "2022-07-14 21:47:34 +0800", "snippet": "143. 重排链表给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln - 1 → Ln请将其重新排列后变为：L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例 1：输入：head = [1,2,3,4]输出：[1,4,2,3]示例 2：输入：head = [1,2,3,4,5]输出：[1,5,2,4,3]提示：链表的长度范围为 [1, 5 * 10e4]1 &lt;= node.val &lt;= 1000 题目链接：https://leetcode.cn/problems/reorder-list题解首先需要找到中间结点，根据中间结点把整个链表分割成两个链表，随后将第二个链表反转一下，最后合并两个链表即可。假设整个链表的长度为n，那么中间结点的位置应该在(n + 1)/2这个位置，将这个结点的next边去除，就可以得到两个链表，而且可以保证第一个链表的长度是大于等于第二个链表长度的，两个链表长度相差不超过1，这是由n的奇偶决定的。最后反转一下第二个链表并且与第一个链表合并即可。代码/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: void reorderList(ListNode* p_head) {\t\t // 计算链表总长度n int n = 0; auto t = p_head; while(t) t = t -&gt; next, n ++; // 断开链表的中间结点，第(n + 1)/2个结点与下个结点断开，使得一个链表变成两个链表 int i = (n + 1) / 2 - 1; t = p_head; while(i) t = t -&gt; next, i --; // 断开两个链表 auto q_tail = t -&gt; next; t -&gt; next = NULL; // 反转第二个链表 t = q_tail; ListNode *last = NULL, *q_head = NULL; while(t){ auto ne = t -&gt; next; t -&gt; next = last; last = t; if(!ne) q_head = t; t = ne; } // 合并两个链表 t = p_head; while(q_head){ auto ne = t -&gt; next; t -&gt; next = q_head; q_head = q_head -&gt; next; t = t -&gt; next; t -&gt; next = ne; t = ne; } return; }};分析时间复杂度O(n)，空间复杂度O(1)。" }, { "title": "Leetcode3.无重复字符的最长子串", "url": "/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode3.%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/", "categories": "计算机技术, 算法", "tags": "滑动窗口, 双指针", "date": "2022-06-29 17:01:19 +0800", "snippet": "3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: s = “abcabcbb”输出: 3 解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2:输入: s = “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3:输入: s = “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 ”wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。提示：0 &lt;= s.length &lt;= 5 * 10e4s 由英文字母、数字、符号和空格组成 题目链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/题解暴力解法用双重循环加哈希表就可以实现，时间复杂度是n²的，空间复杂度为n。滑动窗口的解法需要维护一个区间以及哈希表也可以实现，这个区间里的字符串不能重复，一重循环枚举每个滑动窗口的左端点，然后再加一重循环搜索不重复的子串的右端点位置，最后作差就可以得到答案，右端点是具有单调性的，所以第二重循环最多也只会循环n次，总体时间复杂度和空间复杂度和本文的解法一致。本文使用数组模拟哈希表以及双指针的算法，j表示以i为结尾的不重复字符串的起点位置，用i遍历整个字符串，数组中存储的是每个字符的最后一次出现的位置，由于子串是连续的，j必然是递增的，如果j递减或者不变无法保证子串是不重复的，如果遇到重复字符那么j只能取重复字符的后一个位置才能保证最长，同时也要保证j的单调性，每次遇到重复的字符更新一下j的值来保证j指向的起点是不重复子串的起点。代码：class Solution {public: int lengthOfLongestSubstring(string s) { if(s.empty()) return 0; // 数组均初始化为-1 int hs[128]; memset(hs, -1, sizeof(hs)); int ans = 1; for(int i = 0, j = 0; i &lt; s.size(); i ++){ int idx = s[i] - ' '; // 遇到重复字符的情况，第二个条件保证了j单调 if(hs[idx] != -1 &amp;&amp; j &lt;= hs[idx] + 1){ j = hs[idx] + 1; } // 更新每个字符最后一次出现的下标 hs[idx] = i; ans = max(ans, i - j + 1); } return ans; }};分析：时间复杂度O(n)，空间复杂度O(S)，S表示字符集的大小，标准ASCII码的大小S为128。" }, { "title": "Leetcode206.反转链表", "url": "/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/", "categories": "计算机技术, 算法", "tags": "链表", "date": "2022-06-27 21:37:12 +0800", "snippet": "206. 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。示例 1：输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]示例 2：输入：head = [1,2]输出：[2,1]示例 3：输入：head = []输出：[]提示：链表中节点的数目范围是 [0, 5000]-5000 &lt;= Node.val &lt;= 5000进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 题目链接：https://leetcode.cn/problems/reverse-linked-list/题解朴素做法就不做介绍了，手动模拟创建新的结点并赋值，然后返回头结点即可。介绍进阶中的两种做法，一种是递归，一种是迭代，思路都比较简单，核心就是存储好上一个结点的指针就可以了，在代码中我用$last$变量存储。递归代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* ans; void rev(ListNode* last, ListNode* node){ // 递归结束条件 if(!node -&gt; next) { node -&gt; next = last; ans = node; return; } rev(node, node -&gt; next); // 将next指针指向上个结点 node -&gt; next = last; } ListNode* reverseList(ListNode* head) { if(!head) return nullptr; rev(nullptr, head); return ans; }};分析：时间复杂度O(n)，空间复杂度O(n)，递归的栈的占用空间与结点数量有关。迭代代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode* last = nullptr; ListNode* ans = nullptr; while(head){ auto t = head -&gt; next; // 将next指针指向上个结点 head -&gt; next = last; last = head; // 当结点为空时说明已经迭代到链表结尾 if(!t) ans = head; head = t; } return ans; }};分析：时间复杂度O(n)，空间复杂度O(1)" }, { "title": "模板文章", "url": "/posts/%E6%A8%A1%E6%9D%BF%E6%96%87%E7%AB%A0/", "categories": "计算机技术, 模板", "tags": "模板", "date": "2022-06-27 17:20:00 +0800", "snippet": "一级标题二级标题三级标题分割线代码：#include&lt;iostream&gt;using namespace std;int main(){ cout &lt;&lt; \"Hello World!\"; return 0;}" } ]
