<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>XopowoYpa</title><subtitle>sharing computer tech and science in my blog</subtitle> <updated>2022-08-09T16:04:50+08:00</updated> <author> <name>XopowoYpa</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 XopowoYpa </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Linux网络编程</title><link href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="alternate" type="text/html" title="Linux网络编程" /><published>2022-08-08T20:37:31+08:00</published> <updated>2022-08-09T16:04:28+08:00</updated> <id>/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id> <content src="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" /> <author> <name>XopowoYpa</name> </author> <category term="计算机技术" /> <category term="Linux" /> <summary> 引言 本文主要介绍了Linux环境下的网络编程，主要使用到了socket、select、poll、epoll等API，并且给出相关介绍与使用样例。 字节序 字节序是大于一个字节类型的数据在内存中存放的顺序，字节序分为大端字节序和小端字节序（小端存储和大端存储），大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。 举例： 假设有数据0x 01 02 03 04（4个字节），同时假设内存地址增长方向是从左往右的，那么如果按照小端存储则有： 0x04 03 02 01 按照大端存储则有： 0x01 02 03 04 判断机器是大端还是小端： union{ short v; // 2个字节 char bytes[sizeof(v)]; // char[2] 2个字节 } test; test.v = 0x0102;... </summary> </entry> <entry><title>C++编程工具（Linux）</title><link href="/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/" rel="alternate" type="text/html" title="C++编程工具（Linux）" /><published>2022-07-28T01:34:10+08:00</published> <updated>2022-07-28T01:34:10+08:00</updated> <id>/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/</id> <content src="/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/" /> <author> <name>XopowoYpa</name> </author> <category term="计算机技术" /> <category term="C++" /> <summary> 引言 本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。 本文持续更新中 GCC GCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要介绍GCC在C/C++上的编译应用。 GCC的工作流程 graph LR A([源代码]) --&amp;gt; B[预处理器] B --&amp;gt; C([预处理后源代码]) C --&amp;gt; D[编译器] D --&amp;gt; E([汇编代码]) E --&amp;gt; F[汇编器] F --&amp;gt; G2 G1([启动代码]) --&amp;gt; H G2([目标代码]) --&amp;gt; H G3(... </summary> </entry> <entry><title>C++11 新特性</title><link href="/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/" rel="alternate" type="text/html" title="C++11 新特性" /><published>2022-07-27T08:20:01+08:00</published> <updated>2022-07-30T02:52:56+08:00</updated> <id>/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/</id> <content src="/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/" /> <author> <name>XopowoYpa</name> </author> <category term="计算机技术" /> <category term="C++" /> <summary> 引言 本文主要介绍C++11中的新特性，汇集了书本以及网络上的博客内容，综合成一本手册供自己查阅使用，本文给出基本的使用方法，如有实现文章则该文章将会以超链接的形式给出，有需要可以点击查阅，所有使用到的资料将在文章结尾给出。 本文持续更新中 智能指针 shared_ptr&amp;lt;T&amp;gt; unique_ptr&amp;lt;T&amp;gt; weak_ptr&amp;lt;T&amp;gt; auto_ptr&amp;lt;T&amp;gt; lambda表达式 initializer_list&amp;lt;T&amp;gt; initializer_list&amp;lt;T&amp;gt;是一种模板类型，类似vector&amp;lt;T&amp;gt;，一般可用于传入不定个同类型参数的函数。所属库为&amp;lt;initializer_list&amp;gt;。 常用API 函数 作用 ... </summary> </entry> <entry><title>Redis入门</title><link href="/posts/Redis%E5%85%A5%E9%97%A8/" rel="alternate" type="text/html" title="Redis入门" /><published>2022-07-23T14:29:01+08:00</published> <updated>2022-07-23T20:14:22+08:00</updated> <id>/posts/Redis%E5%85%A5%E9%97%A8/</id> <content src="/posts/Redis%E5%85%A5%E9%97%A8/" /> <author> <name>XopowoYpa</name> </author> <category term="计算机技术" /> <category term="Redis" /> <summary> 介绍 Redis是基于内存的非关系型数据库，它是使用使用 ANSI C 语言编写的数据库系统，不同于传统磁盘数据库系统，它是一种高性能的key-value存储系统，并且还支持集群、分布式、主从同步等配置，它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。 本文主要介绍了Redis的一些实现原理，以及常见的知识点和API。 阅读本文您需要了解：C语言、数据结构、常见算法 本文持续更新中… 数据结构 字符串（string） Redis自己实现了一套字符串结构，即SDS（Simple Dynamic Strings，简单动态字符串），不使用C语言的字符数组，原因是以下三点： 如果想要获取C语言的字符串的值，需要O(n)级别的时间复杂度（即遍历整个字符数组）。 没有比较好的扩容机制，每次扩容都要重新分配空间。 特殊的字符无法处理，因为字符... </summary> </entry> <entry><title>Leetcode124.二叉树中的最大路径和</title><link href="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" rel="alternate" type="text/html" title="Leetcode124.二叉树中的最大路径和" /><published>2022-07-15T21:05:39+08:00</published> <updated>2022-07-15T21:37:40+08:00</updated> <id>/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</id> <content src="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" /> <author> <name>XopowoYpa</name> </author> <category term="计算机技术" /> <category term="算法" /> <summary> 124. 二叉树中的最大路径和 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例 1： 输入：root = [1,2,3] 输出：6 解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6 示例 2： 输入：root = [-10,9,20,null,null,15,7] 输出：42 解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42 提示： 树中节点数目范围是 [1, 3 * 10e4] -1000 &amp;lt;= Node.val &amp;lt;= 1000 题目链接... </summary> </entry> </feed>
