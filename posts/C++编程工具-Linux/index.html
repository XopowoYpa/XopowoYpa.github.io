<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="C++编程工具（Linux）" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="引言 本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。 本文持续更新中 GCC GCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要介绍GCC在C/C++上的编译应用。 GCC的工作流程 graph LR A([源代码]) --&gt; B[预处理器] B --&gt; C([预处理后源代码]) C --&gt; D[编译器] D --&gt; E([汇编代码]) E --&gt; F[汇编器] F --&gt; G2 G1([启动代码]) --&gt; H G2([目标代码]) --&gt; H G3([库代码]) --&gt; H G4([其他目标代码]) --&gt; H H[链接器] --&gt; I([可执行程序]) 图中的源代码一般是.c、.h、.cpp文件。 首先经过预处理器后得到.i文件，预处理器的作用是展开头文件、宏替换、删除注释等。 其次经过编译器把.i文件中的代码转换为汇编代码.s文件，编译器的作用则是将预处理后源代码编译成汇编代码。 随后通过汇编器将汇编代码.i文件转换为目标代码.o文件（机器代码），汇编器的作用则是将汇编代码转换为二进制指令。 最后将不同的.o文件链接成一个可执行程序.exe（windows）或者.out（linux）文件即可，链接器的作用则是链接各种代码形成可执行程序。 GCC常用参数 GCC参数选项 作用 -E 预处理指定文件 -S 编译指定文件（包括了预处理，但是不会进行汇编） -c 编译、汇编指定文件（不进行链接） -o [app] [src][src] -o [app] 将文件src编译成可执行文件app -I [directory] i大写，指定#include包含的搜索目录（静态库需要使用） -g 在编译时候生成调试信息（GDB需要使用） -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -O0/O1/O2/O3 编译器优化的4个级别，O0表示没有优化，O1为缺省值，O3优化级别最高 -l 小写L，指定编译时候，所要包含的库（静态库需要使用） -L 库的搜索路径（静态库需要使用） -fPIC/fpic 生成与位置无关的代码（动态库需要使用） -shared 生成共享目标文件（建立共享库或称动态库） -std 指定C语言的编译标准，如有-std=c99 使用样例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc test.c -E -o test.i # test.cpp -&gt; test.i（预处理代码） gcc test.i -S -o test.s # test.i -&gt; test.s（汇编代码） gcc test.s -c -o test.o # test.s -&gt; test.o（机器代码/二进制文件） gcc test.c -o app # test.cpp -&gt; app（可执行程序） # -I 参数在静态库的样例中查看 # -g 参数在GDB的样例中查看 # 定义了一个DEBUG宏，如果代码中存在宏的条件编译 # 如#ifdef DEBUG ... #else ... #endif，则会判断是否定义了DEBUG # 定义了则会编译#ifdef中的内容，否则是else的内容 gcc test.c -o test -D DEBUG gcc test.c -o test -w # 不生生成任何的warning，比如定义的变量没有使用等 gcc test.c -o -Wall # 生成所有的warning gcc test.c -o test -O3 # 对程序进行“臭氧”优化 # -l 参数在静态库的样例中查看 # -L 参数在静态库的样例中查看 # -fPIC/fpic 参数在动态库的样例中查看 # -shared 参数在动态库的样例中查看 g++ test.cpp -o test -std=c++11 静态库 静态库是指在程序的链接阶段被复制到目标程序当中的库。 静态库的优点： 静态库被打包到到应用程序中加载速度快 发布程序无需提供静态库，移植方便 静态库的缺点： 消耗系统资源，浪费内存（如果有多个程序使用了此静态库，则静态库会被编译多次） 更新、部署、发布麻烦（如果更新了静态库，则需要重新编译使用了此静态库的源代码） 静态库的制作 命名规则：Linux系统中命名格式为libxxx.a（lib和.a固定，xxx是库的名称），Windows系统中格式则是libxxx.lib 通过gcc获得.o文件 使用ar工具将.o文件打包，命令如下： 1 ar rcs libxxx.a file1.o file2.o # xxx.o ... 参数rcs分别表示： r —— 往备存文件（或称库文件）中插入.o文件 c —— 建立备存文件（或称库文件） s —— 生成.o文件的索引 制作样例： 1 2 3 4 5 6 7 8 9 10 11 # 假设有以下文件： #-add.c #-div.c #-head.h #-main.c #-mult.c #-sub.c gcc -c add.c div.c mult.c sub.c # 生成对应的.o文件 ar rcs libcalc.a add.o sub.o mult.o div.o # 生成libcalc.a静态库文件 静态库的使用 1 2 3 4 5 6 7 8 9 10 # 假设有以下文件： #-include/ # -head.h #-lib/ # -libcalc.a #-main.c gcc main.c -o app -I ./include/ -l calc -L ./lib/ # -I表示包含的头文件位置，-l表示包含的库文件名称，-L表示库的搜索目录 ./app # 执行程序 动态库 动态库是指在程序编译时不被链接到目标代码中，而是在程序运行时才被载入的库。 动态库的优点： 可以实现进程间资源共享（各个应用程序都可以共享载入到内存中的动态库） 更新、部署、发布简单（每次更新只需要重新编译库文件即可） 可以控制何时加载动态库（使用到的时候才会去加载） 动态库的缺点： 加载速度比静态库慢 发布程序时需要提供依赖的动态库 动态库的制作 命名规则：Linux系统中命名格式为libxxx.so（lib和.so固定，xxx是库的名称），Windows系统中格式则是libxxx.dll 通过gcc得到.o文件，需要得到和位置无关的代码（-fpic/-fPIC） 通过gcc得到动态库 制作样例： 1 2 gcc -c -fpic add.c div.c mult.c sub.c # xxx.c ... gcc -shared *.o -o libcalc.so 动态库的使用 1 2 3 4 5 6 7 8 9 10 11 12 # 假设有以下文件： #-include/ # -head.h #-lib/ # -libcalc.so #-main.c gcc main.c -o main -I include/ -L lib/ -l calc # 编译 ./main # 执行 # 结果输出 ./main: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 动态库是在程序启动之后动态地加载到内存中，因此需要给定库文件的路径，一般情况下如果没有设定库文件路径，直接编译使用了动态库的源代码会报not found的错误，此时可以通过ldd（list dynamic dependencies）命令检查动态库依赖关系： 1 ldd app Linux系统下的动态库载入需要系统的动态载入器来获取其绝对路径，找到库文件后再将其载入内存即可，对于elf格式的可执行程序是由ld-linux.so来完成的，搜索路径如下所示： elf文件的DT_RPATH段（不常用，用gcc加入链接操作-Wl -rpath指定搜索路径） 环境变量LD_LIBRARY_PATH 通过以下指令： 1 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库的绝对路径(比如/usr/xxx/mylib/) 来添加，这是一种临时的配置，随着终端的退出就会失效，如果想要永久配置，有两种配置方式： 用户级别的配置 进入/home/用户名/.bashrc文件，在文件末尾添加以上export指令，然后输入source .bashrc来更新配置即可。 系统级别的配置 进入etc/profile文件，在文件末尾添加以上export命令，然后更新配置即可。 /etc/ld.so.cache文件列表 ld.so.cache是一个二进制文件，无法直接修改，需要通过修改同目录下的ld.so.conf文件来完成配置，将路径直接加入到文件，然后使用ldconfig指令来更新配置即可。 /lib/或者/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） /usr/lib/或者/usr/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） 最后编译程序和执行程序就可以正常通过了： 1 2 gcc main.c -o main -I include/ -L lib/ -l calc # 编译 ./main # 执行 Makefile Makefile文件定义了一系列的规则来指文件的编译顺序，其作用就是为了自动化编译，使用make指令来完全自动的编译。 Makefile文件命名和规则 文件命名 makefile或者Makefile命名的文件 Makefile规则 一个Makefile文件可以有一个或者多个规则，其规则模板如下： 1 2 3 目标 ...: 依赖 ... 命令（shell 命令） ... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或者目标 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进） Makefile中的其他规则一般都是为第一条规则服务的 GDB CMake 参考资料 [1]. 牛客网——C++高薪面试项目 [2]. CSDN——Linux下动态库(共享库）的制作与使用 [3]. 知乎——linux设置程序搜索动态库路径" /><meta property="og:description" content="引言 本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。 本文持续更新中 GCC GCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要介绍GCC在C/C++上的编译应用。 GCC的工作流程 graph LR A([源代码]) --&gt; B[预处理器] B --&gt; C([预处理后源代码]) C --&gt; D[编译器] D --&gt; E([汇编代码]) E --&gt; F[汇编器] F --&gt; G2 G1([启动代码]) --&gt; H G2([目标代码]) --&gt; H G3([库代码]) --&gt; H G4([其他目标代码]) --&gt; H H[链接器] --&gt; I([可执行程序]) 图中的源代码一般是.c、.h、.cpp文件。 首先经过预处理器后得到.i文件，预处理器的作用是展开头文件、宏替换、删除注释等。 其次经过编译器把.i文件中的代码转换为汇编代码.s文件，编译器的作用则是将预处理后源代码编译成汇编代码。 随后通过汇编器将汇编代码.i文件转换为目标代码.o文件（机器代码），汇编器的作用则是将汇编代码转换为二进制指令。 最后将不同的.o文件链接成一个可执行程序.exe（windows）或者.out（linux）文件即可，链接器的作用则是链接各种代码形成可执行程序。 GCC常用参数 GCC参数选项 作用 -E 预处理指定文件 -S 编译指定文件（包括了预处理，但是不会进行汇编） -c 编译、汇编指定文件（不进行链接） -o [app] [src][src] -o [app] 将文件src编译成可执行文件app -I [directory] i大写，指定#include包含的搜索目录（静态库需要使用） -g 在编译时候生成调试信息（GDB需要使用） -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -O0/O1/O2/O3 编译器优化的4个级别，O0表示没有优化，O1为缺省值，O3优化级别最高 -l 小写L，指定编译时候，所要包含的库（静态库需要使用） -L 库的搜索路径（静态库需要使用） -fPIC/fpic 生成与位置无关的代码（动态库需要使用） -shared 生成共享目标文件（建立共享库或称动态库） -std 指定C语言的编译标准，如有-std=c99 使用样例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc test.c -E -o test.i # test.cpp -&gt; test.i（预处理代码） gcc test.i -S -o test.s # test.i -&gt; test.s（汇编代码） gcc test.s -c -o test.o # test.s -&gt; test.o（机器代码/二进制文件） gcc test.c -o app # test.cpp -&gt; app（可执行程序） # -I 参数在静态库的样例中查看 # -g 参数在GDB的样例中查看 # 定义了一个DEBUG宏，如果代码中存在宏的条件编译 # 如#ifdef DEBUG ... #else ... #endif，则会判断是否定义了DEBUG # 定义了则会编译#ifdef中的内容，否则是else的内容 gcc test.c -o test -D DEBUG gcc test.c -o test -w # 不生生成任何的warning，比如定义的变量没有使用等 gcc test.c -o -Wall # 生成所有的warning gcc test.c -o test -O3 # 对程序进行“臭氧”优化 # -l 参数在静态库的样例中查看 # -L 参数在静态库的样例中查看 # -fPIC/fpic 参数在动态库的样例中查看 # -shared 参数在动态库的样例中查看 g++ test.cpp -o test -std=c++11 静态库 静态库是指在程序的链接阶段被复制到目标程序当中的库。 静态库的优点： 静态库被打包到到应用程序中加载速度快 发布程序无需提供静态库，移植方便 静态库的缺点： 消耗系统资源，浪费内存（如果有多个程序使用了此静态库，则静态库会被编译多次） 更新、部署、发布麻烦（如果更新了静态库，则需要重新编译使用了此静态库的源代码） 静态库的制作 命名规则：Linux系统中命名格式为libxxx.a（lib和.a固定，xxx是库的名称），Windows系统中格式则是libxxx.lib 通过gcc获得.o文件 使用ar工具将.o文件打包，命令如下： 1 ar rcs libxxx.a file1.o file2.o # xxx.o ... 参数rcs分别表示： r —— 往备存文件（或称库文件）中插入.o文件 c —— 建立备存文件（或称库文件） s —— 生成.o文件的索引 制作样例： 1 2 3 4 5 6 7 8 9 10 11 # 假设有以下文件： #-add.c #-div.c #-head.h #-main.c #-mult.c #-sub.c gcc -c add.c div.c mult.c sub.c # 生成对应的.o文件 ar rcs libcalc.a add.o sub.o mult.o div.o # 生成libcalc.a静态库文件 静态库的使用 1 2 3 4 5 6 7 8 9 10 # 假设有以下文件： #-include/ # -head.h #-lib/ # -libcalc.a #-main.c gcc main.c -o app -I ./include/ -l calc -L ./lib/ # -I表示包含的头文件位置，-l表示包含的库文件名称，-L表示库的搜索目录 ./app # 执行程序 动态库 动态库是指在程序编译时不被链接到目标代码中，而是在程序运行时才被载入的库。 动态库的优点： 可以实现进程间资源共享（各个应用程序都可以共享载入到内存中的动态库） 更新、部署、发布简单（每次更新只需要重新编译库文件即可） 可以控制何时加载动态库（使用到的时候才会去加载） 动态库的缺点： 加载速度比静态库慢 发布程序时需要提供依赖的动态库 动态库的制作 命名规则：Linux系统中命名格式为libxxx.so（lib和.so固定，xxx是库的名称），Windows系统中格式则是libxxx.dll 通过gcc得到.o文件，需要得到和位置无关的代码（-fpic/-fPIC） 通过gcc得到动态库 制作样例： 1 2 gcc -c -fpic add.c div.c mult.c sub.c # xxx.c ... gcc -shared *.o -o libcalc.so 动态库的使用 1 2 3 4 5 6 7 8 9 10 11 12 # 假设有以下文件： #-include/ # -head.h #-lib/ # -libcalc.so #-main.c gcc main.c -o main -I include/ -L lib/ -l calc # 编译 ./main # 执行 # 结果输出 ./main: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 动态库是在程序启动之后动态地加载到内存中，因此需要给定库文件的路径，一般情况下如果没有设定库文件路径，直接编译使用了动态库的源代码会报not found的错误，此时可以通过ldd（list dynamic dependencies）命令检查动态库依赖关系： 1 ldd app Linux系统下的动态库载入需要系统的动态载入器来获取其绝对路径，找到库文件后再将其载入内存即可，对于elf格式的可执行程序是由ld-linux.so来完成的，搜索路径如下所示： elf文件的DT_RPATH段（不常用，用gcc加入链接操作-Wl -rpath指定搜索路径） 环境变量LD_LIBRARY_PATH 通过以下指令： 1 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库的绝对路径(比如/usr/xxx/mylib/) 来添加，这是一种临时的配置，随着终端的退出就会失效，如果想要永久配置，有两种配置方式： 用户级别的配置 进入/home/用户名/.bashrc文件，在文件末尾添加以上export指令，然后输入source .bashrc来更新配置即可。 系统级别的配置 进入etc/profile文件，在文件末尾添加以上export命令，然后更新配置即可。 /etc/ld.so.cache文件列表 ld.so.cache是一个二进制文件，无法直接修改，需要通过修改同目录下的ld.so.conf文件来完成配置，将路径直接加入到文件，然后使用ldconfig指令来更新配置即可。 /lib/或者/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） /usr/lib/或者/usr/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） 最后编译程序和执行程序就可以正常通过了： 1 2 gcc main.c -o main -I include/ -L lib/ -l calc # 编译 ./main # 执行 Makefile Makefile文件定义了一系列的规则来指文件的编译顺序，其作用就是为了自动化编译，使用make指令来完全自动的编译。 Makefile文件命名和规则 文件命名 makefile或者Makefile命名的文件 Makefile规则 一个Makefile文件可以有一个或者多个规则，其规则模板如下： 1 2 3 目标 ...: 依赖 ... 命令（shell 命令） ... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或者目标 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进） Makefile中的其他规则一般都是为第一条规则服务的 GDB CMake 参考资料 [1]. 牛客网——C++高薪面试项目 [2]. CSDN——Linux下动态库(共享库）的制作与使用 [3]. 知乎——linux设置程序搜索动态库路径" /><link rel="canonical" href="/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/" /><meta property="og:url" content="/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/" /><meta property="og:site_name" content="XopowoYpa" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-28T01:34:10+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++编程工具（Linux）" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-28T01:34:10+08:00","datePublished":"2022-07-28T01:34:10+08:00","description":"引言 本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。 本文持续更新中 GCC GCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要介绍GCC在C/C++上的编译应用。 GCC的工作流程 graph LR A([源代码]) --&gt; B[预处理器] B --&gt; C([预处理后源代码]) C --&gt; D[编译器] D --&gt; E([汇编代码]) E --&gt; F[汇编器] F --&gt; G2 G1([启动代码]) --&gt; H G2([目标代码]) --&gt; H G3([库代码]) --&gt; H G4([其他目标代码]) --&gt; H H[链接器] --&gt; I([可执行程序]) 图中的源代码一般是.c、.h、.cpp文件。 首先经过预处理器后得到.i文件，预处理器的作用是展开头文件、宏替换、删除注释等。 其次经过编译器把.i文件中的代码转换为汇编代码.s文件，编译器的作用则是将预处理后源代码编译成汇编代码。 随后通过汇编器将汇编代码.i文件转换为目标代码.o文件（机器代码），汇编器的作用则是将汇编代码转换为二进制指令。 最后将不同的.o文件链接成一个可执行程序.exe（windows）或者.out（linux）文件即可，链接器的作用则是链接各种代码形成可执行程序。 GCC常用参数 GCC参数选项 作用 -E 预处理指定文件 -S 编译指定文件（包括了预处理，但是不会进行汇编） -c 编译、汇编指定文件（不进行链接） -o [app] [src][src] -o [app] 将文件src编译成可执行文件app -I [directory] i大写，指定#include包含的搜索目录（静态库需要使用） -g 在编译时候生成调试信息（GDB需要使用） -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -O0/O1/O2/O3 编译器优化的4个级别，O0表示没有优化，O1为缺省值，O3优化级别最高 -l 小写L，指定编译时候，所要包含的库（静态库需要使用） -L 库的搜索路径（静态库需要使用） -fPIC/fpic 生成与位置无关的代码（动态库需要使用） -shared 生成共享目标文件（建立共享库或称动态库） -std 指定C语言的编译标准，如有-std=c99 使用样例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 gcc test.c -E -o test.i # test.cpp -&gt; test.i（预处理代码） gcc test.i -S -o test.s # test.i -&gt; test.s（汇编代码） gcc test.s -c -o test.o # test.s -&gt; test.o（机器代码/二进制文件） gcc test.c -o app # test.cpp -&gt; app（可执行程序） # -I 参数在静态库的样例中查看 # -g 参数在GDB的样例中查看 # 定义了一个DEBUG宏，如果代码中存在宏的条件编译 # 如#ifdef DEBUG ... #else ... #endif，则会判断是否定义了DEBUG # 定义了则会编译#ifdef中的内容，否则是else的内容 gcc test.c -o test -D DEBUG gcc test.c -o test -w # 不生生成任何的warning，比如定义的变量没有使用等 gcc test.c -o -Wall # 生成所有的warning gcc test.c -o test -O3 # 对程序进行“臭氧”优化 # -l 参数在静态库的样例中查看 # -L 参数在静态库的样例中查看 # -fPIC/fpic 参数在动态库的样例中查看 # -shared 参数在动态库的样例中查看 g++ test.cpp -o test -std=c++11 静态库 静态库是指在程序的链接阶段被复制到目标程序当中的库。 静态库的优点： 静态库被打包到到应用程序中加载速度快 发布程序无需提供静态库，移植方便 静态库的缺点： 消耗系统资源，浪费内存（如果有多个程序使用了此静态库，则静态库会被编译多次） 更新、部署、发布麻烦（如果更新了静态库，则需要重新编译使用了此静态库的源代码） 静态库的制作 命名规则：Linux系统中命名格式为libxxx.a（lib和.a固定，xxx是库的名称），Windows系统中格式则是libxxx.lib 通过gcc获得.o文件 使用ar工具将.o文件打包，命令如下： 1 ar rcs libxxx.a file1.o file2.o # xxx.o ... 参数rcs分别表示： r —— 往备存文件（或称库文件）中插入.o文件 c —— 建立备存文件（或称库文件） s —— 生成.o文件的索引 制作样例： 1 2 3 4 5 6 7 8 9 10 11 # 假设有以下文件： #-add.c #-div.c #-head.h #-main.c #-mult.c #-sub.c gcc -c add.c div.c mult.c sub.c # 生成对应的.o文件 ar rcs libcalc.a add.o sub.o mult.o div.o # 生成libcalc.a静态库文件 静态库的使用 1 2 3 4 5 6 7 8 9 10 # 假设有以下文件： #-include/ # -head.h #-lib/ # -libcalc.a #-main.c gcc main.c -o app -I ./include/ -l calc -L ./lib/ # -I表示包含的头文件位置，-l表示包含的库文件名称，-L表示库的搜索目录 ./app # 执行程序 动态库 动态库是指在程序编译时不被链接到目标代码中，而是在程序运行时才被载入的库。 动态库的优点： 可以实现进程间资源共享（各个应用程序都可以共享载入到内存中的动态库） 更新、部署、发布简单（每次更新只需要重新编译库文件即可） 可以控制何时加载动态库（使用到的时候才会去加载） 动态库的缺点： 加载速度比静态库慢 发布程序时需要提供依赖的动态库 动态库的制作 命名规则：Linux系统中命名格式为libxxx.so（lib和.so固定，xxx是库的名称），Windows系统中格式则是libxxx.dll 通过gcc得到.o文件，需要得到和位置无关的代码（-fpic/-fPIC） 通过gcc得到动态库 制作样例： 1 2 gcc -c -fpic add.c div.c mult.c sub.c # xxx.c ... gcc -shared *.o -o libcalc.so 动态库的使用 1 2 3 4 5 6 7 8 9 10 11 12 # 假设有以下文件： #-include/ # -head.h #-lib/ # -libcalc.so #-main.c gcc main.c -o main -I include/ -L lib/ -l calc # 编译 ./main # 执行 # 结果输出 ./main: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory 动态库是在程序启动之后动态地加载到内存中，因此需要给定库文件的路径，一般情况下如果没有设定库文件路径，直接编译使用了动态库的源代码会报not found的错误，此时可以通过ldd（list dynamic dependencies）命令检查动态库依赖关系： 1 ldd app Linux系统下的动态库载入需要系统的动态载入器来获取其绝对路径，找到库文件后再将其载入内存即可，对于elf格式的可执行程序是由ld-linux.so来完成的，搜索路径如下所示： elf文件的DT_RPATH段（不常用，用gcc加入链接操作-Wl -rpath指定搜索路径） 环境变量LD_LIBRARY_PATH 通过以下指令： 1 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库的绝对路径(比如/usr/xxx/mylib/) 来添加，这是一种临时的配置，随着终端的退出就会失效，如果想要永久配置，有两种配置方式： 用户级别的配置 进入/home/用户名/.bashrc文件，在文件末尾添加以上export指令，然后输入source .bashrc来更新配置即可。 系统级别的配置 进入etc/profile文件，在文件末尾添加以上export命令，然后更新配置即可。 /etc/ld.so.cache文件列表 ld.so.cache是一个二进制文件，无法直接修改，需要通过修改同目录下的ld.so.conf文件来完成配置，将路径直接加入到文件，然后使用ldconfig指令来更新配置即可。 /lib/或者/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） /usr/lib/或者/usr/lib64/（不推荐使用，因为有很多库文件，可能会出现同名替换的问题） 最后编译程序和执行程序就可以正常通过了： 1 2 gcc main.c -o main -I include/ -L lib/ -l calc # 编译 ./main # 执行 Makefile Makefile文件定义了一系列的规则来指文件的编译顺序，其作用就是为了自动化编译，使用make指令来完全自动的编译。 Makefile文件命名和规则 文件命名 makefile或者Makefile命名的文件 Makefile规则 一个Makefile文件可以有一个或者多个规则，其规则模板如下： 1 2 3 目标 ...: 依赖 ... 命令（shell 命令） ... 目标：最终要生成的文件（伪目标除外） 依赖：生成目标所需要的文件或者目标 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进） Makefile中的其他规则一般都是为第一条规则服务的 GDB CMake 参考资料 [1]. 牛客网——C++高薪面试项目 [2]. CSDN——Linux下动态库(共享库）的制作与使用 [3]. 知乎——linux设置程序搜索动态库路径","headline":"C++编程工具（Linux）","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/"},"url":"/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/"}</script><title>C++编程工具（Linux） | XopowoYpa</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XopowoYpa"><meta name="application-name" content="XopowoYpa"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar/img.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XopowoYpa</a></div><div class="site-subtitle font-italic">sharing computer tech and science</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/XopowoYpa" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>C++编程工具（Linux）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>C++编程工具（Linux）</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1658943250" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-07-28 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://twitter.com/username">XopowoYpa</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2533 字"> <em>14 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="引言"><span class="mr-2">引言</span><a href="#引言" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。</p><p><strong>本文持续更新中</strong></p><h1 id="gcc">GCC</h1><p>GCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要介绍GCC在C/C++上的编译应用。</p><h2 id="gcc的工作流程"><span class="mr-2">GCC的工作流程</span><a href="#gcc的工作流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><pre><code class="language-mermaid">graph LR
	A([源代码]) --&gt; B[预处理器]
	B --&gt; C([预处理后源代码])
	C --&gt; D[编译器]
	D --&gt; E([汇编代码])
	E --&gt; F[汇编器]
	F --&gt; G2
	G1([启动代码]) --&gt; H
	G2([目标代码]) --&gt; H
	G3([库代码]) --&gt; H
	G4([其他目标代码]) --&gt; H
	H[链接器] --&gt; I([可执行程序])	
</code></pre><ol><li>图中的源代码一般是.c、.h、.cpp文件。<li>首先经过预处理器后得到.i文件，<strong>预处理器的作用是展开头文件、宏替换、删除注释等。</strong><li>其次经过编译器把.i文件中的代码转换为汇编代码.s文件，<strong>编译器的作用则是将预处理后源代码编译成汇编代码</strong>。<li>随后通过汇编器将汇编代码.i文件转换为目标代码.o文件（机器代码），<strong>汇编器的作用则是将汇编代码转换为二进制指令</strong>。<li>最后将不同的.o文件链接成一个可执行程序.exe（windows）或者.out（linux）文件即可，<strong>链接器的作用则是链接各种代码形成可执行程序</strong>。</ol><h2 id="gcc常用参数"><span class="mr-2">GCC常用参数</span><a href="#gcc常用参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th>GCC参数选项<th>作用<tbody><tr><td>-E<td>预处理指定文件<tr><td>-S<td>编译指定文件（包括了预处理，但是不会进行汇编）<tr><td>-c<td>编译、汇编指定文件（不进行链接）<tr><td>-o [app] [src]<br />[src] -o [app]<td>将文件src编译成可执行文件app<tr><td>-I [directory]<td>i大写，指定#include包含的搜索目录（静态库需要使用）<tr><td>-g<td>在编译时候生成调试信息（GDB需要使用）<tr><td>-D<td>在程序编译的时候，指定一个宏<tr><td>-w<td>不生成任何警告信息<tr><td>-Wall<td>生成所有警告信息<tr><td>-O0/O1/O2/O3<td>编译器优化的4个级别，O0表示没有优化，O1为缺省值，O3优化级别最高<tr><td>-l<td>小写L，指定编译时候，所要包含的库（静态库需要使用）<tr><td>-L<td>库的搜索路径（静态库需要使用）<tr><td>-fPIC/fpic<td>生成与位置无关的代码（动态库需要使用）<tr><td>-shared<td>生成共享目标文件（建立共享库或称动态库）<tr><td>-std<td>指定C语言的编译标准，如有-std=c99</table></div><p>使用样例：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre>gcc test.c <span class="nt">-E</span> <span class="nt">-o</span> test.i <span class="c"># test.cpp -&gt; test.i（预处理代码）</span>

gcc test.i <span class="nt">-S</span> <span class="nt">-o</span> test.s <span class="c"># test.i -&gt; test.s（汇编代码）</span>

gcc test.s <span class="nt">-c</span> <span class="nt">-o</span> test.o <span class="c"># test.s -&gt; test.o（机器代码/二进制文件）</span>

gcc test.c <span class="nt">-o</span> app <span class="c"># test.cpp -&gt; app（可执行程序）</span>

<span class="c"># -I 参数在静态库的样例中查看</span>

<span class="c"># -g 参数在GDB的样例中查看</span>

<span class="c"># 定义了一个DEBUG宏，如果代码中存在宏的条件编译</span>
<span class="c"># 如#ifdef DEBUG ... #else ... #endif，则会判断是否定义了DEBUG</span>
<span class="c"># 定义了则会编译#ifdef中的内容，否则是else的内容</span>
gcc test.c <span class="nt">-o</span> <span class="nb">test</span> <span class="nt">-D</span> DEBUG 
gcc test.c <span class="nt">-o</span> <span class="nb">test</span> <span class="nt">-w</span> <span class="c"># 不生生成任何的warning，比如定义的变量没有使用等</span>

gcc test.c <span class="nt">-o</span> <span class="nt">-Wall</span> <span class="c"># 生成所有的warning</span>

gcc test.c <span class="nt">-o</span> <span class="nb">test</span> <span class="nt">-O3</span> <span class="c"># 对程序进行“臭氧”优化</span>

<span class="c"># -l 参数在静态库的样例中查看</span>

<span class="c"># -L 参数在静态库的样例中查看</span>

<span class="c"># -fPIC/fpic 参数在动态库的样例中查看</span>

<span class="c"># -shared 参数在动态库的样例中查看</span>

g++ test.cpp <span class="nt">-o</span> <span class="nb">test</span> <span class="nt">-std</span><span class="o">=</span>c++11

</pre></table></code></div></div><h1 id="静态库">静态库</h1><p>静态库是指<strong>在程序的链接阶段被复制到目标程序当中的库</strong>。</p><p>静态库的优点：</p><ol><li>静态库被打包到到应用程序中加载速度快<li>发布程序无需提供静态库，移植方便</ol><p>静态库的缺点：</p><ol><li>消耗系统资源，浪费内存（如果有多个程序使用了此静态库，则静态库会被编译多次）<li>更新、部署、发布麻烦（如果更新了静态库，则需要重新编译使用了此静态库的源代码）</ol><h2 id="静态库的制作"><span class="mr-2">静态库的制作</span><a href="#静态库的制作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>命名规则：<strong>Linux系统中命名格式为libxxx.a</strong>（lib和.a固定，xxx是库的名称），<strong>Windows系统中格式则是libxxx.lib</strong></p></blockquote><ol><li>通过gcc获得.o文件<li>使用ar工具将.o文件打包，命令如下：</ol><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ar rcs libxxx.a file1.o file2.o <span class="c"># xxx.o ...  </span>
</pre></table></code></div></div><p>参数rcs分别表示：</p><ul><li>r —— 往备存文件（或称库文件）中插入.o文件<li>c —— 建立备存文件（或称库文件）<li>s —— 生成.o文件的索引</ul><p>制作样例：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># 假设有以下文件：</span>
<span class="c">#-add.c</span>
<span class="c">#-div.c</span>
<span class="c">#-head.h</span>
<span class="c">#-main.c</span>
<span class="c">#-mult.c</span>
<span class="c">#-sub.c</span>

gcc <span class="nt">-c</span> add.c div.c mult.c sub.c <span class="c"># 生成对应的.o文件</span>

ar rcs libcalc.a add.o sub.o mult.o div.o <span class="c"># 生成libcalc.a静态库文件</span>
</pre></table></code></div></div><h2 id="静态库的使用"><span class="mr-2">静态库的使用</span><a href="#静态库的使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c"># 假设有以下文件：</span>
<span class="c">#-include/</span>
<span class="c">#	-head.h</span>
<span class="c">#-lib/</span>
<span class="c">#	-libcalc.a</span>
<span class="c">#-main.c</span>

gcc main.c <span class="nt">-o</span> app <span class="nt">-I</span> ./include/ <span class="nt">-l</span> calc <span class="nt">-L</span> ./lib/ <span class="c"># -I表示包含的头文件位置，-l表示包含的库文件名称，-L表示库的搜索目录</span>

./app <span class="c"># 执行程序</span>
</pre></table></code></div></div><h1 id="动态库">动态库</h1><p>动态库是指<strong>在程序编译时不被链接到目标代码中，而是在程序运行时才被载入的库</strong>。</p><p>动态库的优点：</p><ol><li>可以实现进程间资源共享（各个应用程序都可以共享载入到内存中的动态库）<li>更新、部署、发布简单（每次更新只需要重新编译库文件即可）<li>可以控制何时加载动态库（使用到的时候才会去加载）</ol><p>动态库的缺点：</p><ol><li>加载速度比静态库慢<li>发布程序时需要提供依赖的动态库</ol><h2 id="动态库的制作"><span class="mr-2">动态库的制作</span><a href="#动态库的制作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>命名规则：<strong>Linux系统中命名格式为libxxx.so</strong>（lib和.so固定，xxx是库的名称），<strong>Windows系统中格式则是libxxx.dll</strong></p></blockquote><ol><li>通过gcc得到.o文件，需要得到和位置无关的代码（-fpic/-fPIC）<li>通过gcc得到动态库</ol><p>制作样例：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>gcc <span class="nt">-c</span> <span class="nt">-fpic</span> add.c div.c mult.c sub.c <span class="c"># xxx.c ...</span>
gcc <span class="nt">-shared</span> <span class="k">*</span>.o <span class="nt">-o</span> libcalc.so
</pre></table></code></div></div><h2 id="动态库的使用"><span class="mr-2">动态库的使用</span><a href="#动态库的使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-sh highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 假设有以下文件：</span>
<span class="c">#-include/</span>
<span class="c">#	-head.h</span>
<span class="c">#-lib/</span>
<span class="c">#	-libcalc.so</span>
<span class="c">#-main.c</span>

gcc main.c <span class="nt">-o</span> main <span class="nt">-I</span> include/ <span class="nt">-L</span> lib/ <span class="nt">-l</span> calc <span class="c"># 编译</span>

./main <span class="c"># 执行</span>
<span class="c"># 结果输出</span>
./main: error <span class="k">while </span>loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory
</pre></table></code></div></div><p><strong>动态库是在程序启动之后动态地加载到内存中，因此需要给定库文件的路径，一般情况下如果没有设定库文件路径，直接编译使用了动态库的源代码会报not found的错误</strong>，此时可以通过ldd（list dynamic dependencies）命令检查动态库依赖关系：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ldd app
</pre></table></code></div></div><p>Linux系统下的动态库载入需要系统的动态载入器来获取其绝对路径，找到库文件后再将其载入内存即可，对于elf格式的可执行程序是由ld-linux.so来完成的，<strong>搜索路径如下所示：</strong></p><ol><li><p>elf文件的<strong>DT_RPATH段</strong>（不常用，用gcc加入链接操作-Wl -rpath指定搜索路径）</p><li><p>环境变量<strong>LD_LIBRARY_PATH</strong></p><p>通过以下指令：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:库的绝对路径<span class="o">(</span>比如/usr/xxx/mylib/<span class="o">)</span>
</pre></table></code></div></div><p>来添加，这是一种临时的配置，随着终端的退出就会失效，如果想要永久配置，有两种配置方式：</p><ul><li><p>用户级别的配置</p><p>进入/home/用户名/.bashrc文件，在文件末尾添加以上export指令，然后输入<strong>source .bashrc</strong>来更新配置即可。</p><li><p>系统级别的配置</p><p>进入etc/profile文件，在文件末尾添加以上export命令，然后更新配置即可。</p></ul><li><p><strong>/etc/ld.so.cache</strong>文件列表</p><p><strong>ld.so.cache</strong>是一个二进制文件，无法直接修改，需要通过修改同目录下的<strong>ld.so.conf</strong>文件来完成配置，将路径直接加入到文件，然后使用<strong>ldconfig</strong>指令来更新配置即可。</p><li><p><strong>/lib/</strong>或者<strong>/lib64/</strong>（不推荐使用，因为有很多库文件，可能会出现同名替换的问题）</p><li><p><strong>/usr/lib/</strong>或者<strong>/usr/lib64/</strong>（不推荐使用，因为有很多库文件，可能会出现同名替换的问题）</p></ol><p>最后编译程序和执行程序就可以正常通过了：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>gcc main.c <span class="nt">-o</span> main <span class="nt">-I</span> include/ <span class="nt">-L</span> lib/ <span class="nt">-l</span> calc <span class="c"># 编译</span>
./main <span class="c"># 执行</span>
</pre></table></code></div></div><h1 id="makefile">Makefile</h1><p>Makefile文件定义了一系列的规则来指文件的编译顺序，其作用就是为了自动化编译，使用make指令来完全自动的编译。</p><h2 id="makefile文件命名和规则"><span class="mr-2">Makefile文件命名和规则</span><a href="#makefile文件命名和规则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>文件命名</p><p>makefile或者Makefile命名的文件</p><li><p>Makefile规则</p><ul><li><p>一个Makefile文件可以有一个或者多个规则，其规则模板如下：</p><div class="language-makefile highlighter-rouge"><div class="code-header"> <span data-label-text="Makefile"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">目标 ...</span><span class="o">:</span> <span class="nf">依赖 ...</span>
	命令（shell 命令）
	...
</pre></table></code></div></div><ul><li>目标：最终要生成的文件（伪目标除外）<li>依赖：生成目标所需要的文件或者目标<li>命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进）</ul><li><p>Makefile中的其他规则一般都是为第一条规则服务的</p></ul></ul><h1 id="gdb">GDB</h1><h1 id="cmake">CMake</h1><h2 id="参考资料"><span class="mr-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>[1]. <a href="https://www.nowcoder.com/courses/cover/live/504">牛客网——C++高薪面试项目</a></p><p>[2]. <a href="https://blog.csdn.net/weixin_51483516/article/details/120621135">CSDN——Linux下动态库(共享库）的制作与使用</a></p><p>[3]. <a href="https://zhuanlan.zhihu.com/p/383824348">知乎——linux设置程序搜索动态库路径</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/'>计算机技术</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/linux/" class="post-tag no-text-decoration" >Linux</a> <a href="/tags/gcc/" class="post-tag no-text-decoration" >GCC</a> <a href="/tags/%E9%9D%99%E6%80%81%E5%BA%93/" class="post-tag no-text-decoration" >静态库</a> <a href="/tags/%E5%8A%A8%E6%80%81%E5%BA%93/" class="post-tag no-text-decoration" >动态库</a> <a href="/tags/makefile/" class="post-tag no-text-decoration" >Makefile</a> <a href="/tags/gdb/" class="post-tag no-text-decoration" >GDB</a> <a href="/tags/cmake/" class="post-tag no-text-decoration" >CMake</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C%2B%2B%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%EF%BC%88Linux%EF%BC%89+-+XopowoYpa&url=%2Fposts%2FC%2B%2B%25E7%25BC%2596%25E7%25A8%258B%25E5%25B7%25A5%25E5%2585%25B7-Linux%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C%2B%2B%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%EF%BC%88Linux%EF%BC%89+-+XopowoYpa&u=%2Fposts%2FC%2B%2B%25E7%25BC%2596%25E7%25A8%258B%25E5%25B7%25A5%25E5%2585%25B7-Linux%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FC%2B%2B%25E7%25BC%2596%25E7%25A8%258B%25E5%25B7%25A5%25E5%2585%25B7-Linux%2F&text=C%2B%2B%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%EF%BC%88Linux%EF%BC%89+-+XopowoYpa" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a><li><a href="/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/">C++11 新特性</a><li><a href="/posts/Redis%E5%85%A5%E9%97%A8/">Redis入门</a><li><a href="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/">Leetcode124.二叉树中的最大路径和</a><li><a href="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">Leetcode206.反转链表</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> <a class="post-tag" href="/tags/c-11/">C++11</a> <a class="post-tag" href="/tags/cmake/">CMake</a> <a class="post-tag" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a> <a class="post-tag" href="/tags/gcc/">GCC</a> <a class="post-tag" href="/tags/gdb/">GDB</a> <a class="post-tag" href="/tags/i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a> <a class="post-tag" href="/tags/i-o%E6%A8%A1%E5%9E%8B/">I/O模型</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><div class="card-body"> <em class="small" data-ts="1659962251" data-df="YYYY-MM-DD" > 2022-08-08 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux网络编程</h3><div class="text-muted small"><p> 引言 本文主要介绍了Linux环境下的网络编程，主要使用到了socket、select、poll、epoll等API，并且给出相关介绍与使用样例。 字节序 字节序是大于一个字节类型的数据在内存中存放的顺序，字节序分为大端字节序和小端字节序（小端存储和大端存储），大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。 举例： 假设有数据0x ...</p></div></div></a></div><div class="card"> <a href="/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/"><div class="card-body"> <em class="small" data-ts="1658881201" data-df="YYYY-MM-DD" > 2022-07-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++11 新特性</h3><div class="text-muted small"><p> 引言 本文主要介绍C++11中的新特性，汇集了书本以及网络上的博客内容，综合成一本手册供自己查阅使用，本文给出基本的使用方法，如有实现文章则该文章将会以超链接的形式给出，有需要可以点击查阅，所有使用到的资料将在文章结尾给出。 本文持续更新中 智能指针 shared_ptr&amp;lt;T&amp;gt; unique_ptr&amp;lt;T&amp;gt; weak_ptr&amp;lt;T&amp;gt; auto_p...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%A8%A1%E6%9D%BF%E6%96%87%E7%AB%A0/"><div class="card-body"> <em class="small" data-ts="1656321600" data-df="YYYY-MM-DD" > 2022-06-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>模板文章</h3><div class="text-muted small"><p> 一级标题 二级标题 三级标题 分割线 代码： #include&amp;lt;iostream&amp;gt; using namespace std; int main(){ cout &amp;lt;&amp;lt; &quot;Hello World!&quot;; return 0; }</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/" class="btn btn-outline-primary" prompt="上一篇"><p>C++11 新特性</p></a> <a href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="btn btn-outline-primary" prompt="下一篇"><p>Linux网络编程</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">XopowoYpa</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> <a class="post-tag" href="/tags/c-11/">C++11</a> <a class="post-tag" href="/tags/cmake/">CMake</a> <a class="post-tag" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a> <a class="post-tag" href="/tags/gcc/">GCC</a> <a class="post-tag" href="/tags/gdb/">GDB</a> <a class="post-tag" href="/tags/i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a> <a class="post-tag" href="/tags/i-o%E6%A8%A1%E5%9E%8B/">I/O模型</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
