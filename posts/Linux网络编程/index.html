<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Linux网络编程" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="引言 本文主要介绍了Linux环境下的网络编程，主要使用到了socket、select、poll、epoll等API，并且给出相关介绍与使用样例。 字节序 字节序是大于一个字节类型的数据在内存中存放的顺序，字节序分为大端字节序和小端字节序（小端存储和大端存储），大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。 举例： 假设有数据0x 01 02 03 04（4个字节），同时假设内存地址增长方向是从左往右的，那么如果按照小端存储则有： 0x04 03 02 01 按照大端存储则有： 0x01 02 03 04 判断机器是大端还是小端： 1 2 3 4 5 6 7 8 9 union{ short v; // 2个字节 char bytes[sizeof(v)]; // char[2] 2个字节 } test; test.v = 0x0102; if((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) cout &lt;&lt; &quot;大端存储&quot; &lt;&lt; endl; else if((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1))cout &lt;&lt; &quot;小端存储&quot; &lt;&lt; endl; 字节序转换 API 如果格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端会错误解释数据。解决的办法是：发送端总是以大端序发送数据，接收端根据自己的情况将大端序转换为自己需要的字节序。 TCP/IP中规定了一种数据表示格式，即大端序，从而保证数据在不同主机之间传输可以被正确解释。 Socket提供了封装好的转换API： 1 2 3 4 5 6 7 8 #include&lt;arpa/inet.h&gt; // h表示 host，n表示network，s表示unsigned short，l表示unsigned int // 转换端口用 uint16_t htons(uint16_t hostshort); // 主机字节序转网络字节序，返回值是大端的 uint16_t ntohs(uint16_t netshort); // 反之，返回值根据主机而定 // 转换ip用 uint32_t htonl(uint32_t hostlong); // 主机字节序转网络字节序，返回值是大端的 uint32_t ntohl(uint32_t netlong); // 反之，返回值根据主机而定 IP地址转换 API 通常我们喜欢用可读性好的字符串来表示ip地址，比如127.0.0.1，实际上在机器中存储的是一个无符号整型，把它用来表示地址，因此需要互相转换，具体API如下（比较旧的API）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include&lt;arpa/inet.h&gt; typedef unsigned int in_addr_t; struct in_addr{ in_addr_t s_addr; }; // 十进制形式ipv4地址字符串cp转换为ipv4网络字节序的数并返回 in_addr_t inet_addr(const char *cp); // 十进制形式ipv4地址字符串cp，转换为ipv4网络字节序列的地址inp // 返回1表示转换成功，0表示输入非法 int inet_aton(const char* cp, struct in_addr *inp); // ipv4网络字节序地址转换为十进制形式ipv4地址字符串 char *inet_ntoa(struct in_addr_in) 最新的API（ipv4和ipv6都可以使用）： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include&lt;arpa/inet.h&gt; // 命名中p表示十进制IP字符串，n表示netaddr即网络字节序的整数 /* 参数说明 af - 表示协议类型（af：AF_INET、AF_INET6） src - 表示十进制形式IP地址 dst - 表示转换完成后的网络字节序整数 返回值 - 1表示转换成功，0表示输入非法，-1表示协议非法 */ int inet_pton(int af, const char *src, void *dst); // 反过程，size表示可用的字节数的大小，即表示dst的size // 返回值表示转换后的字符串的地址，和dst是相同值 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); socket API socket提供了一套网络的API，用户可以通过socket来传输数据。通用socket地址里面封装了第一层的接口，专用socket地址封装了第二层的接口，用户主要是通过专用socket接口来使用socket。 通用socket地址 socket地址为一个结构体，其定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include&lt;sys/socket.h&gt; typedef unsigned short int sa_family_t; // ipv4使用 struct sockaddr{ sa_family_t sa_family; char sa_data[4]; }; // ipv6使用 struct sockaddr_storage{ sa_family_t sa_family; unsigned long int __ss_align; // 字节对齐用 char __ss_padding[128 - sizeof(__ss_align)]; }; sa_family成员是地址族类型（sa_family_t）的变量，地址族与协议族类型相对应，两者实际存储的值都是相同的，因此可以混用，常见的协议族和地址族如下： 协议族 地址族 描述 地址值含义 长度 PF_UNIX AF_UNIX Unix本地域协议族 文件的路径名 最长108字节 PF_INET AF_INET TCP/IPv4协议族 16位的端口号以及32位的ipv4地址 6字节 PF_INET6 AF_INET6 TCP/IPv6协议族 16位的端口号、32位流标识、128位的ipv6地址 26字节 专用socket地址 由于很多网络编程函数都是基于ipv4的，那时候使用的都是通用socket地址，为了兼容，现在的通用socket地址退化成了类似于void *的作用，专用socket地址使用sockaddr_in或者sockaddr_in6，那么只需要给API传入sockaddr_in或者sockaddr_in6即可，函数内部会自动把专用的地址类型转化为通用地址类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # define __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int)) #include&lt;netinet/in.h&gt; typedef unsigned int in_addr_t; typedef unsigned short in_port_t; struct in_addr{ in_addr_t s_addr; }; struct sockaddr_in{ sa_family_t sin_family; // 地址族 in_port_t sin_port; // 端口 struct in_addr sin_addr; // 地址 unsigned char sin_zero[sizeof(struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof(in_port_t) - sizeof(struct in_addr)]; // 填充 }; struct sockaddr_in6{ sa_family_t sin6_family; in_port_t sin6_port; uint32_t sin6_flow_info; // ipv6的flow table struct in6_addr sin6_addr; // 类似于in_addr uint32_t sin6_scope_id; // ipv6的scope id }; 常用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt; // 该头文件包含了上面两个头文件 /* 参数说明 domain - 表示协议族有：AF_INET、AF_INET6、AF_UNIX等 type - 表示通信过程中的协议类型，常见的有：SOCK_STREAM（流式协议）、SOCK_DGRAM（报式协议）等 protocol - 表示具体的协议，一般传入0，比方说对于SOCK_STREAM填0就表示默认使用TCP，对于SOCK_DGRAM填0表示默认使用UDP 返回值 - 为文件描述符(fd)，如果失败则返回-1 */ int socket(int domain, int type, int protocol); // 创建套接字 /* 参数说明 sockfd - 表示通过socket函数得到的fd sockaddr - 表示需要绑定的地址和端口 addrlen - 表示addr占用的内存大小 返回值 - 成功0，失败-1 */ int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 将fd与本地的IP和port进行绑定 /* 参数说明 sockfd - 同上 backlog - 表示未连接队列和已经连接队列和的最大值，如果超过这个最大值则放弃连接，已连接表示已经经过3次握手的，未连接表示还没完成3次握手，一般设置成5就可以 */ int listen(int sockfd, int backlog); // 监听有socket上有无客户端连接 /* 参数说明 sockfd - 同上 sockaddr - 记录了连接成功后客户端的地址信息 addrlen - 表示addr占用的内存大小（注意是以指针传递） 返回值 - 成功返回用于通信的fd（不同于监听连接的fd），失败返回-1 */ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // 接收客户端连接 /* 参数说明 sockfd - 表示客户端用于通信的fd addr - 表示客户端要连接的服务端的地址信息 addrlen - 表示addr占用的内存大小 返回值 - 成功0，失败-1 */ int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 客户端连接服务器 ssize_t write(int fd, const void *buf, size_t count); // 写数据 sszie_t read(int fd, void *buf, size_t count); // 读数据 简单TCP服务端样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include&lt;iostream&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;cstring&gt; using namespace std; int main(){ // 1. 创建socket int lsnfd = socket(AF_INET, SOCK_STREAM, 0); // 使用ipv4和TCP协议创建socket if(lsnfd == -1){ // 意外处理 perror(&quot;socket create failed&quot;); return -1; } // 2. 绑定socket sockaddr_in saddr; // 创建专用socket地址 saddr.sin_family = AF_INET; // 或者使用PF_INET，都表示使用ipv4协议 saddr.sin_addr.s_addr = 0; // ip地址设置为本机（0.0.0.0）,或者使用INADDR_ANY来绑定所有网卡的ip地址 // 如果要使用指定IP地址则应该使用以下代码，将本机字节序转换为网络字节序 // inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;saddr.sin_addr_s_addr); saddr.sin_port = htons(9999); // 设置socket端口号为9999，并转换为网络字节序 int rt = bind(lsnfd, (sockaddr *)&amp;saddr, sizeof(saddr)); // 绑定 if(rt == -1){ // 意外处理 perror(&quot;bind failed&quot;); return -1; } // 3. 监听 rt = listen(lsnfd, 8); // 监听创建的socket，并且把两个监听队列的总和上限设置为8 if(rt == -1){ // 意外处理 perror(&quot;listen failed&quot;); return -1; } // 4. 接受客户端的连接 sockaddr_in cliaddr; // 用于接收客户端的地址信息 socklen_t sz = sizeof(cliaddr); int clifd = accept(lsnfd, (sockaddr *)&amp;cliaddr, &amp;sz); // 阻塞的，直到有客户端连接进来 if(clifd == -1){ // 意外处理 perror(&quot;accept from client failed&quot;); return -1; } // 5. 读取客户端地址信息 char cliip[16]; // IP地址字符串的最长字节数为16（4个大小为3字节的数字、3个1字节的点、1个字节的字符串结尾\0） inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliip, sizeof(cliip)); // 将客户端收到的IP地址（网络字节序）转为本机字节序 unsigned short cliport = ntohs(cliaddr.sin_port); // 接收客户端的端口（网络字节序），并且转换为本机字节序 cout &lt;&lt; &quot;[Server] Accept a clinet connection which from &quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; endl; // 输出客户端地址和端口 // 6. 读取客户端的数据 char recvbuf[1024]; // 创建缓存 memset(recvbuf, 0, sizeof(recvbuf)); int len = read(clifd, recvbuf, sizeof(recvbuf)); // 从accept到的客户端fd读取数据 if(len == -1){ // 意外处理 perror(&quot;read failed&quot;); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; &quot;[Server] Receive a message from client (&quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;) : &quot; &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; &quot;[Server] client (&quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;) disconnect&quot; &lt;&lt; endl; } // 7. 给客户端返回数据 char msg[] = &quot;server has received your message&quot;; rt = write(clifd, msg, sizeof(msg)); // 8. 关闭文件描述符（只通信一次就退出） close(clifd); close(lsnfd); return 0; } 简单TCP客户端样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include&lt;iostream&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;cstring&gt; using namespace std; int main(){ // 1. 创建socket int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1){ perror(&quot;create socket failed&quot;); return -1; } // 2. 连接服务器 sockaddr_in saddr; saddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.85.128&quot;, &amp;saddr.sin_addr.s_addr); // 设置服务器ip地址 saddr.sin_port = htons(9999); // 设置服务器端口 int rt = connect(fd, (sockaddr*)&amp;saddr, sizeof(saddr)); if(rt == -1){ perror(&quot;connect failed&quot;); return -1; } // 3. 给服务器发送数据 char msg[] = &quot;Hello!&quot;; write(fd, msg, sizeof(msg)); // 4. 读取服务器返回的数据 char recvbuf[1024]; memset(recvbuf, 0, sizeof(recvbuf)); int len = read(fd, recvbuf, sizeof(recvbuf)); if(len == -1){ // 意外处理 perror(&quot;read failed&quot;); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; &quot;[Client] Receive a message from server : &quot; &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; &quot;[Client] Server closed&quot; &lt;&lt; endl; } // 5. 关闭文件描述符 close(fd); return 0; } I/O多路复用 I/O多路复用又称I/O多路转接，I/O多路复用可以让程序同时监听多个文件描述符(file descriptor)，从而提高程序的性能。Linux下实现I/O多路复用的API有select、poll和epoll。 常见的I/O模型有： 阻塞IO模型（Blocking I/O, BIO） 程序阻塞等待数据，有数据就去处理，没数据就在等待。 优点：不占用CPU的时间片 缺点：同一时刻只能处理一个，效率低 如果有多个数据需要处理，那么就要通过多进程或者多线程的方式来处理。 缺点：创建线程或者进程调度占用内存资源，线程或者进程的调度占用CPU资源 非阻塞IO模型（Non-blocking I/O, NIO） 程序不阻塞等待数据，但是需要轮询（会使用到系统调用），每隔一小段时间去查询是否有数据进来，有就去处理。如果需要处理的数据有很多，即有多个客户端连接到服务器，那么轮询会大量消耗系统资源。 优点：提高程序的执行效率 缺点：需要占用更多CPU和系统资源 IO多路复用模型 I/O多路复用则是把查询交给了内核去做，让内核通知用户，有什么数据需要处理。I/O多路复用实现有select、poll和epoll，简单来说select和poll只通知有数据到达了，但是不知道是哪些数据到达了，需要用户去轮询，epoll则会告知哪些数据到达了，用户直接去读取即可。 信号驱动IO模型 信号驱动不再使用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（使用系统调用sigaction来发出SIGIO信号），然后用户可以去做别的事，不用阻塞。当内核数据准备好后，再通过SIGIO信号通知用户，然后用户再去读数据。 异步IO模型（Asynchronous I/O, AIO） 前面的模型每当有数据需要读取时，都会发生数据读取时产生的阻塞，因为用户需要从内核空间拷贝到用户空间，因此都不是异步I/O。异步I/O模型实现了IO全流程的非阻塞，用户发出系统调用后，直接返回去处理自己的事情，等内核数据准备好，将数据拷贝到用户空间，发送信号通知用户IO操作执行完毕。 I/O多路复用 API select select API select使用流程： 调用select，监听列表中的文件描述符，直到列表中一个文件描述符或者多个文件描述符进行I/O操作时，select才返回（select是阻塞的，对文件描述符的操作是由内核完成的） 返回时，select会告诉有多少文件描述符需要操作 select工作流程：（结合API） fd_set会从用户空间拷贝到内核空间，然后遍历fd_set的每个标志位来判断是否要监听，如果有文件描述符变化了，那么会把更改过后的fd_set再拷贝到用户空间，用户也需要遍历fd_set的每个标志位来判断是否要操作数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include&lt;sys/time.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; /* fd_set typedef long int __fd_mask; struct fd_set{ __fd_mask __fds_bits[__FD_SETSIZE / _NFDBITS]; }; sizeof(fd_set) = 128 // 占用了1024位 */ /*timeval struct timeval{ long tv_sec; // 秒 long tv_usec; // 微秒 }; */ /* 参数说明 nfds - 委托内核检测的最大文件描述符的值再加上1 readfds - 委托内核检测文件描述符是否有读操作的集合（检测读缓冲区有没有数据）,fd_set类型可以看成是一个很大的整数，里面每一位（标志位）都表示一个fd，0表示不需要检测的fd，1表示需要检测的fd，由于是个指针，这个参数也会返回内核检测到的可以读取的fd的信息（可以读标志位为1，否则为0） writefds - 委托内核文件描述符是否有写操作的集合（检测写缓冲区是否满了，满了标志位为0，没满标志位为1） exceptfds - 检测发生异常的文件描述符的集合 timeout - 设置超时时间，值为NULL为永久阻塞直到检测fd有变化，值为0表示不阻塞直接返回，值大于0表示阻塞对应时间 返回值 - -1表示失败, 大于等于0表示检测的集合中有对应的文件描述符发生了变化 */ int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); // 将set中fd对应的标志位，置为0 void FD_CLR(int fd, fd_set *set); // 判断set中fd对应的标志位是0还是1并返回 int FD_ISSET(int fd, fd_set *set); // 将set中fd对应的标志位，置为1 void FD_SET(int fd, fd_set *set); // 将set中所有标志位全部初始化为0 voif FD_ZERO(fd_set *set); select使用样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // int lfd = socket(...); // ... // bind(...); // listen(...); // 创建fd_set，存储需要检测文件描述符 fd_set rdset, tmp; // 因为内核会更改fd_set，因此可以把tmp交给内核修改，然后使用rdset复原即可 FD_ZERO(&amp;rdset); // 初始化为0 FD_SET(lfd, &amp;rdset); // 把监听fd设置为1 int maxfd = lfd; // 初始化最大的fd while(1){ tmp = rdset; int rt = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); // 阻塞到有数据进来（或者说是有客户端连接） if(rt == -1){ // 意外处理 perror(&quot;select failed&quot;); exit(-1); } else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(FD_ISSET(lfd, &amp;tmp)){ // 判断lfd是否有数据可操作（或者说是有客户端连接） // int cfd = accept(...); FD_SET(cfd, &amp;rdset); // 将新的fd加入集合中 maxfd = max(maxfd, cfd); // 更新最大的fd } } for(int i = lfd + 1; i &lt;= maxfd; i ++){ // 轮询rdset，lfd是第一个创建的fd所以初始值可以直接赋为lfd + 1 if(FD_ISSET(i, &amp;tmp)){ // 判断fd是否有数据来了 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(i, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(&quot;read failed&quot;); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; FD_CLR(i, &amp;rdset); } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } } 以上的例子可以看到并没有使用到多线程和多进程就可以处理多个客户端的数据。 select 的缺陷 每次都需要把fd_set从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历fd_set的每个标志位，时间复杂度是O(n)的。 select支持的文件描述符数量太小了，只有1024个。 fd_set不能重用，每次都需要重置。 poll poll API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include&lt;poll.h&gt; struct pollfd{ int fd; // 委托内核检测的文件描述符 short events; // 委托内核检测fd的什么事件（用户设置的变量） short revents; // fd实际发生的事件（内核操作的变量） }; /* 参数介绍 fds - 是一个pollfd的结构体数组指针，这是一个需要检测的fd的集合 nfds - 表示pollfd结构体数组中最后一个有效元素的下标加1 timeout - 阻塞时长，-1表示阻塞（直到fds有变化），0表示不阻塞，大于0表示阻塞对应的时长(ms) 返回值 - -1表示失败，大于等于0表示成功，表示有对应个fd发生变化 */ int poll(struct pollfd *fds, nfds_t nfds, int timeout); pollfd中的events和revents的取值有： 事件 值 作为events的值 作为revents的值 说明 读事件 POLLINPOLLRDNORMPOLLRDBANDPOLLPRI √√√√ √√√√ 普通或优先带数据可读普通数据可读优先级带数据可读高优先级数据可读 写事件 POLLOUTPOLLWRNORMPOLLWRBAND √√√ √√√ 普通或优先带数据可写普通数据可写优先级带数据可写 错误事件 POLLERRPOLLHUPPOLLNVAL   √√√ 发生错误发生挂起描述不是打开的文件 比较常用的读事件的值为POLLIN，写事件的值为POLLOUT，如果既要检测读事件也要检测写事件可以写成POLLIN | POLLOUT。 poll使用样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // int lfd = socket(...); // ... // bind(...); // listen(...); const int FDSIZE = 1024; pollfd fds[FDSIZE]; // 数组大小可以任意指定，不一定是1024 for(int i = 0; i &lt; FDSIZE; i ++){ // 初始化pollfd结构体数组 fds[i].fd = -1; fds[i].events = POLLIN; } fds[0].fd = lfd; // 监听fd加入数组中 int nfds = 0; // 记录有效fd的最大下标，为了方便实现直接记录数组的最大下标即可 while(1){ int rt = poll(fds, nfds + 1, -1); // 阻塞，等待数据进来（或等待客户端连接） if(rt == -1){ // 意外处理 perror(&quot;poll failed&quot;); exit(-1); } else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(fds[0].revents &amp; POLLIN){ // 表示监听文件描述符lfd的revents中存在POLLIN事件（位运算） // int cfd = accept(...); // 找pollfd数组中空闲位置插入新加入的fd（有新的客户端连接） for(int i = 1; i &lt; FDSIZE; i ++){ if(i &gt; nfds) nfds = i; // 记录最大下标（不一定是有效） if(fds[i].fd == -1){ fds[i].fd = cfd; fds[i].events = POLLIN; break; } } } } for(int i = 1; i &lt;= nfds; i ++){ // 轮询fds，0是监听fd，因此需要从1开始遍历 if(fds[i].revents &amp; POLLIN){ // 判断fds元素的revents中是否存在POLLIN事件（位运算） char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(fds[i].fd, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(&quot;read failed&quot;); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; close(fds[i].fd); // 关闭对应fd fds[i].fd = -1; // 将pollfd数组对应元素的fd置为-1，空出位置 } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } } poll的缺陷 需要把pollfd数组从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历pollfd数组的每个revents来判断是否有数据变化，时间复杂度是O(n)的。 epoll epoll API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include&lt;sys/epoll.h&gt; /* struct eventpoll{ //... struct rb_root rbr; // 红黑树根节点，红黑树中存储需要检测的文件描述符 struct list_head rdlist; // 就绪队列双链表，存储有数据变化的文件描述符 // ... }; */ /* 参数说明 size - 目前没有意义了，随便写一个大于0的数 返回值 - 失败返回-1，成功返回文件描述符fd，用于操控内核空间中的实例(eventpoll类型) */ int epoll_create(int size); // 在内核空间中创建实例(eventpoll类型) typedef union epoll_data{ void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; strut epoll_event{ uint32_t events; // 需要检测的epoll事件（EPOLL_IN、EPOLLOUT、EPOLLERR、EPOLLET等） epoll_data_t data; // 存储用户的数据信息，一般只存fd }; /* 参数介绍 epfd - 通过epoll_create创建出来的eventpoll实例对应的fd op - 对eventpoll实例的操作选项，比如添加fd、删除fd、修改fd检测的操作等（分别对应EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD） fd - 需要进行操作的文件描述符 event - 记录了fd需要检测的事件（删除操作输入NULL即可） 返回值 - 成功返回0，失败返回-1 */ int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 操作内核空间的eventpoll实例 /* 参数介绍 epfd - 同上 events - 存储所有发生了变化的fd maxevents - events数组的大小 timeout - 阻塞时间，-1表示阻塞（直到有fd发生变化），0表示不阻塞，大于表示要阻塞的时长(ms) 返回值 - 成功返回发生变化的fd的个数，失败返回-1 */ int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // 检测是否有发生变化的fd，从内核空间的就绪队列中拷贝出来，存储在events中 epoll的两种工作模式 水平触发（Level Triggered, LT） LT是默认的工作方式，同时支持阻塞和非阻塞的socket，在这种工作模式中，内核会不断通知用户是否有文件描述符就绪了，然后用户可以对就绪的文件描述符进行IO操作，如果用户没有进行操作的话，内核还是会继续通知用户。 边缘触发（Edge Triggered, ET） ET是较为高速的工作方式，只支持非阻塞的socket，当有文件描述符变成就绪时，内核只会通知用户一次（only once），后续不会为这个文件描述符向用户发送就绪通知，直到用户操作了文件描述符使得这个文件描述符不再是就绪状态。 比如有个fd就绪了有8个字节需要读取，用户只读取了2个字节，剩余6个字节没有读取，在下次内核发现这个fd里面还有数据没读的话，在ET模式下内核就不会再通知用户（直到又有新数据到来了，更改了该fd的就绪状态，但是也是会按照缓冲区的顺序读取数据），在LT模式下内核就会去通知用户。 ET模式减少了内核通知用户的次数，因此效率比LT模式要高，但是epoll在ET模式的时候，必须使用非阻塞的套接字接口，因为内核只通知用户一次，用户应该一次把数据读完，所以就不能使用阻塞的读写操作，否则就会导致进程或者线程饿死（因为需要阻塞等待数据的读或者写）。 epoll使用案例 LT模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // int lfd = socket(...); // ... // bind(...); // listen(...); int epfd = epoll_create(100); // 创建eventpoll实例，参数随便写个大于0的数 // 将监听fd添加到eventpoll实例中 epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); const int FDSIZE = 1024; epoll_event epevs[FDSIZE]; // 接收从内核检测到的fd集合，大小无限制 while(1){ // 阻塞等待数据来（或等客户端连接） // 返回值是发生变化fd的数目 // 由于是水平触发，如果数据没有读完，epoll_wait会把没有读完的fd放入就绪队列中再返回 int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ // 失败处理 perror(&quot;epoll wait failed&quot;); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd; if(curfd == lfd){ // 判断是否是监听fd，如果为真说明有客户端连接 // ... // int cfd = accept(...); // 将接收到的客户端fd加入内核检测的fd集合中 epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ // 说明是客户端fd，判断是读操作的情况 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ // 错误处理 perror(&quot;cfd read failed&quot;); exit(-1); } else if(len == 0){ // 客户端关闭连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); //从eventpoll实例中删除该fd close(curfd); } else if(len &gt; 0){ // 读到数据了进行对应处理 cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } } else if(epevs[i].events &amp; EPOLLOUT){ //客户端fd写操作的情况 // 写操作逻辑 } } } // 关闭创建出来的lfd和epfd close(lfd); close(epfd); ET模式 相比于LT模式，ET需要多更改一些设置，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 // int lfd = socket(...); // ... // bind(...); // listen(...); int epfd = epoll_create(100); epoll_event epev; epev.events = EPOLLIN; // 监听fd应该为水平触发 epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); const int FDSIZE = 1024; epoll_event epevs[FDSIZE]; while(1){ // 由于是边缘触发，内核只通知一次 // 如果数据没读完，那么后面的数据就无法读到（需要一次性读完） int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ perror(&quot;epoll wait failed&quot;); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd; if(curfd == lfd){ // ... // int cfd = accept(...); // 设置cfd为非阻塞，以用于后续非阻塞读写 // 头文件需要额外添加fcntl.h int flag = fcntl(cfd, F_GETFL); // 得到cfd的flag fcntl(cfd, F_SETFL, flag | O_NONBLOCK); // 设置flag为非阻塞 // 设置为边缘触发 // // --------------------------------// epev.events = EPOLLIN | EPOLLET; // --------------------------------// epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ /* 无法一次性读取数据 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ perror(&quot;cfd read failed&quot;); exit(-1); } else if(len == 0){ cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); } else if(len &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } */ // 一次性读取所有数据，使用循环来分别读取出来 char buf[1024]; memset(buf, 0, sizeof(bug)); int len = 0; while( (len = read(curfd, buf, sizeof(buf))) &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // 读操作逻辑 // write(...) } if(len == 0){ cout &lt;&lt; &quot;clinet closed&quot; &lt;&lt; endl; } else if(len == -1){ // 需要额外头文件errno.h if(errno == EAGAIN){ // 数据读完可能产生的错误 // 处理逻辑 } else{ perror(&quot;read failed&quot;); exit(-1); } } } else if(epevs[i].events &amp; EPOLLOUT){ // 写操作逻辑 } } } close(lfd); close(epfd); 参考资料 [1]. 牛客网——C++高薪面试项目 [2]. 掘金——看一遍就理解：IO模型详解" /><meta property="og:description" content="引言 本文主要介绍了Linux环境下的网络编程，主要使用到了socket、select、poll、epoll等API，并且给出相关介绍与使用样例。 字节序 字节序是大于一个字节类型的数据在内存中存放的顺序，字节序分为大端字节序和小端字节序（小端存储和大端存储），大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。 举例： 假设有数据0x 01 02 03 04（4个字节），同时假设内存地址增长方向是从左往右的，那么如果按照小端存储则有： 0x04 03 02 01 按照大端存储则有： 0x01 02 03 04 判断机器是大端还是小端： 1 2 3 4 5 6 7 8 9 union{ short v; // 2个字节 char bytes[sizeof(v)]; // char[2] 2个字节 } test; test.v = 0x0102; if((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) cout &lt;&lt; &quot;大端存储&quot; &lt;&lt; endl; else if((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1))cout &lt;&lt; &quot;小端存储&quot; &lt;&lt; endl; 字节序转换 API 如果格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端会错误解释数据。解决的办法是：发送端总是以大端序发送数据，接收端根据自己的情况将大端序转换为自己需要的字节序。 TCP/IP中规定了一种数据表示格式，即大端序，从而保证数据在不同主机之间传输可以被正确解释。 Socket提供了封装好的转换API： 1 2 3 4 5 6 7 8 #include&lt;arpa/inet.h&gt; // h表示 host，n表示network，s表示unsigned short，l表示unsigned int // 转换端口用 uint16_t htons(uint16_t hostshort); // 主机字节序转网络字节序，返回值是大端的 uint16_t ntohs(uint16_t netshort); // 反之，返回值根据主机而定 // 转换ip用 uint32_t htonl(uint32_t hostlong); // 主机字节序转网络字节序，返回值是大端的 uint32_t ntohl(uint32_t netlong); // 反之，返回值根据主机而定 IP地址转换 API 通常我们喜欢用可读性好的字符串来表示ip地址，比如127.0.0.1，实际上在机器中存储的是一个无符号整型，把它用来表示地址，因此需要互相转换，具体API如下（比较旧的API）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include&lt;arpa/inet.h&gt; typedef unsigned int in_addr_t; struct in_addr{ in_addr_t s_addr; }; // 十进制形式ipv4地址字符串cp转换为ipv4网络字节序的数并返回 in_addr_t inet_addr(const char *cp); // 十进制形式ipv4地址字符串cp，转换为ipv4网络字节序列的地址inp // 返回1表示转换成功，0表示输入非法 int inet_aton(const char* cp, struct in_addr *inp); // ipv4网络字节序地址转换为十进制形式ipv4地址字符串 char *inet_ntoa(struct in_addr_in) 最新的API（ipv4和ipv6都可以使用）： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include&lt;arpa/inet.h&gt; // 命名中p表示十进制IP字符串，n表示netaddr即网络字节序的整数 /* 参数说明 af - 表示协议类型（af：AF_INET、AF_INET6） src - 表示十进制形式IP地址 dst - 表示转换完成后的网络字节序整数 返回值 - 1表示转换成功，0表示输入非法，-1表示协议非法 */ int inet_pton(int af, const char *src, void *dst); // 反过程，size表示可用的字节数的大小，即表示dst的size // 返回值表示转换后的字符串的地址，和dst是相同值 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); socket API socket提供了一套网络的API，用户可以通过socket来传输数据。通用socket地址里面封装了第一层的接口，专用socket地址封装了第二层的接口，用户主要是通过专用socket接口来使用socket。 通用socket地址 socket地址为一个结构体，其定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include&lt;sys/socket.h&gt; typedef unsigned short int sa_family_t; // ipv4使用 struct sockaddr{ sa_family_t sa_family; char sa_data[4]; }; // ipv6使用 struct sockaddr_storage{ sa_family_t sa_family; unsigned long int __ss_align; // 字节对齐用 char __ss_padding[128 - sizeof(__ss_align)]; }; sa_family成员是地址族类型（sa_family_t）的变量，地址族与协议族类型相对应，两者实际存储的值都是相同的，因此可以混用，常见的协议族和地址族如下： 协议族 地址族 描述 地址值含义 长度 PF_UNIX AF_UNIX Unix本地域协议族 文件的路径名 最长108字节 PF_INET AF_INET TCP/IPv4协议族 16位的端口号以及32位的ipv4地址 6字节 PF_INET6 AF_INET6 TCP/IPv6协议族 16位的端口号、32位流标识、128位的ipv6地址 26字节 专用socket地址 由于很多网络编程函数都是基于ipv4的，那时候使用的都是通用socket地址，为了兼容，现在的通用socket地址退化成了类似于void *的作用，专用socket地址使用sockaddr_in或者sockaddr_in6，那么只需要给API传入sockaddr_in或者sockaddr_in6即可，函数内部会自动把专用的地址类型转化为通用地址类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # define __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int)) #include&lt;netinet/in.h&gt; typedef unsigned int in_addr_t; typedef unsigned short in_port_t; struct in_addr{ in_addr_t s_addr; }; struct sockaddr_in{ sa_family_t sin_family; // 地址族 in_port_t sin_port; // 端口 struct in_addr sin_addr; // 地址 unsigned char sin_zero[sizeof(struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof(in_port_t) - sizeof(struct in_addr)]; // 填充 }; struct sockaddr_in6{ sa_family_t sin6_family; in_port_t sin6_port; uint32_t sin6_flow_info; // ipv6的flow table struct in6_addr sin6_addr; // 类似于in_addr uint32_t sin6_scope_id; // ipv6的scope id }; 常用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt; // 该头文件包含了上面两个头文件 /* 参数说明 domain - 表示协议族有：AF_INET、AF_INET6、AF_UNIX等 type - 表示通信过程中的协议类型，常见的有：SOCK_STREAM（流式协议）、SOCK_DGRAM（报式协议）等 protocol - 表示具体的协议，一般传入0，比方说对于SOCK_STREAM填0就表示默认使用TCP，对于SOCK_DGRAM填0表示默认使用UDP 返回值 - 为文件描述符(fd)，如果失败则返回-1 */ int socket(int domain, int type, int protocol); // 创建套接字 /* 参数说明 sockfd - 表示通过socket函数得到的fd sockaddr - 表示需要绑定的地址和端口 addrlen - 表示addr占用的内存大小 返回值 - 成功0，失败-1 */ int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 将fd与本地的IP和port进行绑定 /* 参数说明 sockfd - 同上 backlog - 表示未连接队列和已经连接队列和的最大值，如果超过这个最大值则放弃连接，已连接表示已经经过3次握手的，未连接表示还没完成3次握手，一般设置成5就可以 */ int listen(int sockfd, int backlog); // 监听有socket上有无客户端连接 /* 参数说明 sockfd - 同上 sockaddr - 记录了连接成功后客户端的地址信息 addrlen - 表示addr占用的内存大小（注意是以指针传递） 返回值 - 成功返回用于通信的fd（不同于监听连接的fd），失败返回-1 */ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // 接收客户端连接 /* 参数说明 sockfd - 表示客户端用于通信的fd addr - 表示客户端要连接的服务端的地址信息 addrlen - 表示addr占用的内存大小 返回值 - 成功0，失败-1 */ int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 客户端连接服务器 ssize_t write(int fd, const void *buf, size_t count); // 写数据 sszie_t read(int fd, void *buf, size_t count); // 读数据 简单TCP服务端样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include&lt;iostream&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;cstring&gt; using namespace std; int main(){ // 1. 创建socket int lsnfd = socket(AF_INET, SOCK_STREAM, 0); // 使用ipv4和TCP协议创建socket if(lsnfd == -1){ // 意外处理 perror(&quot;socket create failed&quot;); return -1; } // 2. 绑定socket sockaddr_in saddr; // 创建专用socket地址 saddr.sin_family = AF_INET; // 或者使用PF_INET，都表示使用ipv4协议 saddr.sin_addr.s_addr = 0; // ip地址设置为本机（0.0.0.0）,或者使用INADDR_ANY来绑定所有网卡的ip地址 // 如果要使用指定IP地址则应该使用以下代码，将本机字节序转换为网络字节序 // inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;saddr.sin_addr_s_addr); saddr.sin_port = htons(9999); // 设置socket端口号为9999，并转换为网络字节序 int rt = bind(lsnfd, (sockaddr *)&amp;saddr, sizeof(saddr)); // 绑定 if(rt == -1){ // 意外处理 perror(&quot;bind failed&quot;); return -1; } // 3. 监听 rt = listen(lsnfd, 8); // 监听创建的socket，并且把两个监听队列的总和上限设置为8 if(rt == -1){ // 意外处理 perror(&quot;listen failed&quot;); return -1; } // 4. 接受客户端的连接 sockaddr_in cliaddr; // 用于接收客户端的地址信息 socklen_t sz = sizeof(cliaddr); int clifd = accept(lsnfd, (sockaddr *)&amp;cliaddr, &amp;sz); // 阻塞的，直到有客户端连接进来 if(clifd == -1){ // 意外处理 perror(&quot;accept from client failed&quot;); return -1; } // 5. 读取客户端地址信息 char cliip[16]; // IP地址字符串的最长字节数为16（4个大小为3字节的数字、3个1字节的点、1个字节的字符串结尾\0） inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliip, sizeof(cliip)); // 将客户端收到的IP地址（网络字节序）转为本机字节序 unsigned short cliport = ntohs(cliaddr.sin_port); // 接收客户端的端口（网络字节序），并且转换为本机字节序 cout &lt;&lt; &quot;[Server] Accept a clinet connection which from &quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; endl; // 输出客户端地址和端口 // 6. 读取客户端的数据 char recvbuf[1024]; // 创建缓存 memset(recvbuf, 0, sizeof(recvbuf)); int len = read(clifd, recvbuf, sizeof(recvbuf)); // 从accept到的客户端fd读取数据 if(len == -1){ // 意外处理 perror(&quot;read failed&quot;); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; &quot;[Server] Receive a message from client (&quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;) : &quot; &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; &quot;[Server] client (&quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;) disconnect&quot; &lt;&lt; endl; } // 7. 给客户端返回数据 char msg[] = &quot;server has received your message&quot;; rt = write(clifd, msg, sizeof(msg)); // 8. 关闭文件描述符（只通信一次就退出） close(clifd); close(lsnfd); return 0; } 简单TCP客户端样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include&lt;iostream&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;cstring&gt; using namespace std; int main(){ // 1. 创建socket int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1){ perror(&quot;create socket failed&quot;); return -1; } // 2. 连接服务器 sockaddr_in saddr; saddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.85.128&quot;, &amp;saddr.sin_addr.s_addr); // 设置服务器ip地址 saddr.sin_port = htons(9999); // 设置服务器端口 int rt = connect(fd, (sockaddr*)&amp;saddr, sizeof(saddr)); if(rt == -1){ perror(&quot;connect failed&quot;); return -1; } // 3. 给服务器发送数据 char msg[] = &quot;Hello!&quot;; write(fd, msg, sizeof(msg)); // 4. 读取服务器返回的数据 char recvbuf[1024]; memset(recvbuf, 0, sizeof(recvbuf)); int len = read(fd, recvbuf, sizeof(recvbuf)); if(len == -1){ // 意外处理 perror(&quot;read failed&quot;); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; &quot;[Client] Receive a message from server : &quot; &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; &quot;[Client] Server closed&quot; &lt;&lt; endl; } // 5. 关闭文件描述符 close(fd); return 0; } I/O多路复用 I/O多路复用又称I/O多路转接，I/O多路复用可以让程序同时监听多个文件描述符(file descriptor)，从而提高程序的性能。Linux下实现I/O多路复用的API有select、poll和epoll。 常见的I/O模型有： 阻塞IO模型（Blocking I/O, BIO） 程序阻塞等待数据，有数据就去处理，没数据就在等待。 优点：不占用CPU的时间片 缺点：同一时刻只能处理一个，效率低 如果有多个数据需要处理，那么就要通过多进程或者多线程的方式来处理。 缺点：创建线程或者进程调度占用内存资源，线程或者进程的调度占用CPU资源 非阻塞IO模型（Non-blocking I/O, NIO） 程序不阻塞等待数据，但是需要轮询（会使用到系统调用），每隔一小段时间去查询是否有数据进来，有就去处理。如果需要处理的数据有很多，即有多个客户端连接到服务器，那么轮询会大量消耗系统资源。 优点：提高程序的执行效率 缺点：需要占用更多CPU和系统资源 IO多路复用模型 I/O多路复用则是把查询交给了内核去做，让内核通知用户，有什么数据需要处理。I/O多路复用实现有select、poll和epoll，简单来说select和poll只通知有数据到达了，但是不知道是哪些数据到达了，需要用户去轮询，epoll则会告知哪些数据到达了，用户直接去读取即可。 信号驱动IO模型 信号驱动不再使用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（使用系统调用sigaction来发出SIGIO信号），然后用户可以去做别的事，不用阻塞。当内核数据准备好后，再通过SIGIO信号通知用户，然后用户再去读数据。 异步IO模型（Asynchronous I/O, AIO） 前面的模型每当有数据需要读取时，都会发生数据读取时产生的阻塞，因为用户需要从内核空间拷贝到用户空间，因此都不是异步I/O。异步I/O模型实现了IO全流程的非阻塞，用户发出系统调用后，直接返回去处理自己的事情，等内核数据准备好，将数据拷贝到用户空间，发送信号通知用户IO操作执行完毕。 I/O多路复用 API select select API select使用流程： 调用select，监听列表中的文件描述符，直到列表中一个文件描述符或者多个文件描述符进行I/O操作时，select才返回（select是阻塞的，对文件描述符的操作是由内核完成的） 返回时，select会告诉有多少文件描述符需要操作 select工作流程：（结合API） fd_set会从用户空间拷贝到内核空间，然后遍历fd_set的每个标志位来判断是否要监听，如果有文件描述符变化了，那么会把更改过后的fd_set再拷贝到用户空间，用户也需要遍历fd_set的每个标志位来判断是否要操作数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include&lt;sys/time.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; /* fd_set typedef long int __fd_mask; struct fd_set{ __fd_mask __fds_bits[__FD_SETSIZE / _NFDBITS]; }; sizeof(fd_set) = 128 // 占用了1024位 */ /*timeval struct timeval{ long tv_sec; // 秒 long tv_usec; // 微秒 }; */ /* 参数说明 nfds - 委托内核检测的最大文件描述符的值再加上1 readfds - 委托内核检测文件描述符是否有读操作的集合（检测读缓冲区有没有数据）,fd_set类型可以看成是一个很大的整数，里面每一位（标志位）都表示一个fd，0表示不需要检测的fd，1表示需要检测的fd，由于是个指针，这个参数也会返回内核检测到的可以读取的fd的信息（可以读标志位为1，否则为0） writefds - 委托内核文件描述符是否有写操作的集合（检测写缓冲区是否满了，满了标志位为0，没满标志位为1） exceptfds - 检测发生异常的文件描述符的集合 timeout - 设置超时时间，值为NULL为永久阻塞直到检测fd有变化，值为0表示不阻塞直接返回，值大于0表示阻塞对应时间 返回值 - -1表示失败, 大于等于0表示检测的集合中有对应的文件描述符发生了变化 */ int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); // 将set中fd对应的标志位，置为0 void FD_CLR(int fd, fd_set *set); // 判断set中fd对应的标志位是0还是1并返回 int FD_ISSET(int fd, fd_set *set); // 将set中fd对应的标志位，置为1 void FD_SET(int fd, fd_set *set); // 将set中所有标志位全部初始化为0 voif FD_ZERO(fd_set *set); select使用样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // int lfd = socket(...); // ... // bind(...); // listen(...); // 创建fd_set，存储需要检测文件描述符 fd_set rdset, tmp; // 因为内核会更改fd_set，因此可以把tmp交给内核修改，然后使用rdset复原即可 FD_ZERO(&amp;rdset); // 初始化为0 FD_SET(lfd, &amp;rdset); // 把监听fd设置为1 int maxfd = lfd; // 初始化最大的fd while(1){ tmp = rdset; int rt = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); // 阻塞到有数据进来（或者说是有客户端连接） if(rt == -1){ // 意外处理 perror(&quot;select failed&quot;); exit(-1); } else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(FD_ISSET(lfd, &amp;tmp)){ // 判断lfd是否有数据可操作（或者说是有客户端连接） // int cfd = accept(...); FD_SET(cfd, &amp;rdset); // 将新的fd加入集合中 maxfd = max(maxfd, cfd); // 更新最大的fd } } for(int i = lfd + 1; i &lt;= maxfd; i ++){ // 轮询rdset，lfd是第一个创建的fd所以初始值可以直接赋为lfd + 1 if(FD_ISSET(i, &amp;tmp)){ // 判断fd是否有数据来了 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(i, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(&quot;read failed&quot;); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; FD_CLR(i, &amp;rdset); } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } } 以上的例子可以看到并没有使用到多线程和多进程就可以处理多个客户端的数据。 select 的缺陷 每次都需要把fd_set从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历fd_set的每个标志位，时间复杂度是O(n)的。 select支持的文件描述符数量太小了，只有1024个。 fd_set不能重用，每次都需要重置。 poll poll API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include&lt;poll.h&gt; struct pollfd{ int fd; // 委托内核检测的文件描述符 short events; // 委托内核检测fd的什么事件（用户设置的变量） short revents; // fd实际发生的事件（内核操作的变量） }; /* 参数介绍 fds - 是一个pollfd的结构体数组指针，这是一个需要检测的fd的集合 nfds - 表示pollfd结构体数组中最后一个有效元素的下标加1 timeout - 阻塞时长，-1表示阻塞（直到fds有变化），0表示不阻塞，大于0表示阻塞对应的时长(ms) 返回值 - -1表示失败，大于等于0表示成功，表示有对应个fd发生变化 */ int poll(struct pollfd *fds, nfds_t nfds, int timeout); pollfd中的events和revents的取值有： 事件 值 作为events的值 作为revents的值 说明 读事件 POLLINPOLLRDNORMPOLLRDBANDPOLLPRI √√√√ √√√√ 普通或优先带数据可读普通数据可读优先级带数据可读高优先级数据可读 写事件 POLLOUTPOLLWRNORMPOLLWRBAND √√√ √√√ 普通或优先带数据可写普通数据可写优先级带数据可写 错误事件 POLLERRPOLLHUPPOLLNVAL   √√√ 发生错误发生挂起描述不是打开的文件 比较常用的读事件的值为POLLIN，写事件的值为POLLOUT，如果既要检测读事件也要检测写事件可以写成POLLIN | POLLOUT。 poll使用样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // int lfd = socket(...); // ... // bind(...); // listen(...); const int FDSIZE = 1024; pollfd fds[FDSIZE]; // 数组大小可以任意指定，不一定是1024 for(int i = 0; i &lt; FDSIZE; i ++){ // 初始化pollfd结构体数组 fds[i].fd = -1; fds[i].events = POLLIN; } fds[0].fd = lfd; // 监听fd加入数组中 int nfds = 0; // 记录有效fd的最大下标，为了方便实现直接记录数组的最大下标即可 while(1){ int rt = poll(fds, nfds + 1, -1); // 阻塞，等待数据进来（或等待客户端连接） if(rt == -1){ // 意外处理 perror(&quot;poll failed&quot;); exit(-1); } else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(fds[0].revents &amp; POLLIN){ // 表示监听文件描述符lfd的revents中存在POLLIN事件（位运算） // int cfd = accept(...); // 找pollfd数组中空闲位置插入新加入的fd（有新的客户端连接） for(int i = 1; i &lt; FDSIZE; i ++){ if(i &gt; nfds) nfds = i; // 记录最大下标（不一定是有效） if(fds[i].fd == -1){ fds[i].fd = cfd; fds[i].events = POLLIN; break; } } } } for(int i = 1; i &lt;= nfds; i ++){ // 轮询fds，0是监听fd，因此需要从1开始遍历 if(fds[i].revents &amp; POLLIN){ // 判断fds元素的revents中是否存在POLLIN事件（位运算） char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(fds[i].fd, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(&quot;read failed&quot;); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; close(fds[i].fd); // 关闭对应fd fds[i].fd = -1; // 将pollfd数组对应元素的fd置为-1，空出位置 } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } } poll的缺陷 需要把pollfd数组从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历pollfd数组的每个revents来判断是否有数据变化，时间复杂度是O(n)的。 epoll epoll API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include&lt;sys/epoll.h&gt; /* struct eventpoll{ //... struct rb_root rbr; // 红黑树根节点，红黑树中存储需要检测的文件描述符 struct list_head rdlist; // 就绪队列双链表，存储有数据变化的文件描述符 // ... }; */ /* 参数说明 size - 目前没有意义了，随便写一个大于0的数 返回值 - 失败返回-1，成功返回文件描述符fd，用于操控内核空间中的实例(eventpoll类型) */ int epoll_create(int size); // 在内核空间中创建实例(eventpoll类型) typedef union epoll_data{ void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; strut epoll_event{ uint32_t events; // 需要检测的epoll事件（EPOLL_IN、EPOLLOUT、EPOLLERR、EPOLLET等） epoll_data_t data; // 存储用户的数据信息，一般只存fd }; /* 参数介绍 epfd - 通过epoll_create创建出来的eventpoll实例对应的fd op - 对eventpoll实例的操作选项，比如添加fd、删除fd、修改fd检测的操作等（分别对应EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD） fd - 需要进行操作的文件描述符 event - 记录了fd需要检测的事件（删除操作输入NULL即可） 返回值 - 成功返回0，失败返回-1 */ int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 操作内核空间的eventpoll实例 /* 参数介绍 epfd - 同上 events - 存储所有发生了变化的fd maxevents - events数组的大小 timeout - 阻塞时间，-1表示阻塞（直到有fd发生变化），0表示不阻塞，大于表示要阻塞的时长(ms) 返回值 - 成功返回发生变化的fd的个数，失败返回-1 */ int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // 检测是否有发生变化的fd，从内核空间的就绪队列中拷贝出来，存储在events中 epoll的两种工作模式 水平触发（Level Triggered, LT） LT是默认的工作方式，同时支持阻塞和非阻塞的socket，在这种工作模式中，内核会不断通知用户是否有文件描述符就绪了，然后用户可以对就绪的文件描述符进行IO操作，如果用户没有进行操作的话，内核还是会继续通知用户。 边缘触发（Edge Triggered, ET） ET是较为高速的工作方式，只支持非阻塞的socket，当有文件描述符变成就绪时，内核只会通知用户一次（only once），后续不会为这个文件描述符向用户发送就绪通知，直到用户操作了文件描述符使得这个文件描述符不再是就绪状态。 比如有个fd就绪了有8个字节需要读取，用户只读取了2个字节，剩余6个字节没有读取，在下次内核发现这个fd里面还有数据没读的话，在ET模式下内核就不会再通知用户（直到又有新数据到来了，更改了该fd的就绪状态，但是也是会按照缓冲区的顺序读取数据），在LT模式下内核就会去通知用户。 ET模式减少了内核通知用户的次数，因此效率比LT模式要高，但是epoll在ET模式的时候，必须使用非阻塞的套接字接口，因为内核只通知用户一次，用户应该一次把数据读完，所以就不能使用阻塞的读写操作，否则就会导致进程或者线程饿死（因为需要阻塞等待数据的读或者写）。 epoll使用案例 LT模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // int lfd = socket(...); // ... // bind(...); // listen(...); int epfd = epoll_create(100); // 创建eventpoll实例，参数随便写个大于0的数 // 将监听fd添加到eventpoll实例中 epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); const int FDSIZE = 1024; epoll_event epevs[FDSIZE]; // 接收从内核检测到的fd集合，大小无限制 while(1){ // 阻塞等待数据来（或等客户端连接） // 返回值是发生变化fd的数目 // 由于是水平触发，如果数据没有读完，epoll_wait会把没有读完的fd放入就绪队列中再返回 int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ // 失败处理 perror(&quot;epoll wait failed&quot;); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd; if(curfd == lfd){ // 判断是否是监听fd，如果为真说明有客户端连接 // ... // int cfd = accept(...); // 将接收到的客户端fd加入内核检测的fd集合中 epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ // 说明是客户端fd，判断是读操作的情况 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ // 错误处理 perror(&quot;cfd read failed&quot;); exit(-1); } else if(len == 0){ // 客户端关闭连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); //从eventpoll实例中删除该fd close(curfd); } else if(len &gt; 0){ // 读到数据了进行对应处理 cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } } else if(epevs[i].events &amp; EPOLLOUT){ //客户端fd写操作的情况 // 写操作逻辑 } } } // 关闭创建出来的lfd和epfd close(lfd); close(epfd); ET模式 相比于LT模式，ET需要多更改一些设置，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 // int lfd = socket(...); // ... // bind(...); // listen(...); int epfd = epoll_create(100); epoll_event epev; epev.events = EPOLLIN; // 监听fd应该为水平触发 epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); const int FDSIZE = 1024; epoll_event epevs[FDSIZE]; while(1){ // 由于是边缘触发，内核只通知一次 // 如果数据没读完，那么后面的数据就无法读到（需要一次性读完） int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ perror(&quot;epoll wait failed&quot;); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd; if(curfd == lfd){ // ... // int cfd = accept(...); // 设置cfd为非阻塞，以用于后续非阻塞读写 // 头文件需要额外添加fcntl.h int flag = fcntl(cfd, F_GETFL); // 得到cfd的flag fcntl(cfd, F_SETFL, flag | O_NONBLOCK); // 设置flag为非阻塞 // 设置为边缘触发 // // --------------------------------// epev.events = EPOLLIN | EPOLLET; // --------------------------------// epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ /* 无法一次性读取数据 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ perror(&quot;cfd read failed&quot;); exit(-1); } else if(len == 0){ cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); } else if(len &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } */ // 一次性读取所有数据，使用循环来分别读取出来 char buf[1024]; memset(buf, 0, sizeof(bug)); int len = 0; while( (len = read(curfd, buf, sizeof(buf))) &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // 读操作逻辑 // write(...) } if(len == 0){ cout &lt;&lt; &quot;clinet closed&quot; &lt;&lt; endl; } else if(len == -1){ // 需要额外头文件errno.h if(errno == EAGAIN){ // 数据读完可能产生的错误 // 处理逻辑 } else{ perror(&quot;read failed&quot;); exit(-1); } } } else if(epevs[i].events &amp; EPOLLOUT){ // 写操作逻辑 } } } close(lfd); close(epfd); 参考资料 [1]. 牛客网——C++高薪面试项目 [2]. 掘金——看一遍就理解：IO模型详解" /><link rel="canonical" href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" /><meta property="og:url" content="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" /><meta property="og:site_name" content="XopowoYpa" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-08T20:37:31+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Linux网络编程" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-09T16:04:28+08:00","datePublished":"2022-08-08T20:37:31+08:00","description":"引言 本文主要介绍了Linux环境下的网络编程，主要使用到了socket、select、poll、epoll等API，并且给出相关介绍与使用样例。 字节序 字节序是大于一个字节类型的数据在内存中存放的顺序，字节序分为大端字节序和小端字节序（小端存储和大端存储），大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。 举例： 假设有数据0x 01 02 03 04（4个字节），同时假设内存地址增长方向是从左往右的，那么如果按照小端存储则有： 0x04 03 02 01 按照大端存储则有： 0x01 02 03 04 判断机器是大端还是小端： 1 2 3 4 5 6 7 8 9 union{ short v; // 2个字节 char bytes[sizeof(v)]; // char[2] 2个字节 } test; test.v = 0x0102; if((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) cout &lt;&lt; &quot;大端存储&quot; &lt;&lt; endl; else if((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1))cout &lt;&lt; &quot;小端存储&quot; &lt;&lt; endl; 字节序转换 API 如果格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端会错误解释数据。解决的办法是：发送端总是以大端序发送数据，接收端根据自己的情况将大端序转换为自己需要的字节序。 TCP/IP中规定了一种数据表示格式，即大端序，从而保证数据在不同主机之间传输可以被正确解释。 Socket提供了封装好的转换API： 1 2 3 4 5 6 7 8 #include&lt;arpa/inet.h&gt; // h表示 host，n表示network，s表示unsigned short，l表示unsigned int // 转换端口用 uint16_t htons(uint16_t hostshort); // 主机字节序转网络字节序，返回值是大端的 uint16_t ntohs(uint16_t netshort); // 反之，返回值根据主机而定 // 转换ip用 uint32_t htonl(uint32_t hostlong); // 主机字节序转网络字节序，返回值是大端的 uint32_t ntohl(uint32_t netlong); // 反之，返回值根据主机而定 IP地址转换 API 通常我们喜欢用可读性好的字符串来表示ip地址，比如127.0.0.1，实际上在机器中存储的是一个无符号整型，把它用来表示地址，因此需要互相转换，具体API如下（比较旧的API）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include&lt;arpa/inet.h&gt; typedef unsigned int in_addr_t; struct in_addr{ in_addr_t s_addr; }; // 十进制形式ipv4地址字符串cp转换为ipv4网络字节序的数并返回 in_addr_t inet_addr(const char *cp); // 十进制形式ipv4地址字符串cp，转换为ipv4网络字节序列的地址inp // 返回1表示转换成功，0表示输入非法 int inet_aton(const char* cp, struct in_addr *inp); // ipv4网络字节序地址转换为十进制形式ipv4地址字符串 char *inet_ntoa(struct in_addr_in) 最新的API（ipv4和ipv6都可以使用）： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include&lt;arpa/inet.h&gt; // 命名中p表示十进制IP字符串，n表示netaddr即网络字节序的整数 /* 参数说明 af - 表示协议类型（af：AF_INET、AF_INET6） src - 表示十进制形式IP地址 dst - 表示转换完成后的网络字节序整数 返回值 - 1表示转换成功，0表示输入非法，-1表示协议非法 */ int inet_pton(int af, const char *src, void *dst); // 反过程，size表示可用的字节数的大小，即表示dst的size // 返回值表示转换后的字符串的地址，和dst是相同值 const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); socket API socket提供了一套网络的API，用户可以通过socket来传输数据。通用socket地址里面封装了第一层的接口，专用socket地址封装了第二层的接口，用户主要是通过专用socket接口来使用socket。 通用socket地址 socket地址为一个结构体，其定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 #include&lt;sys/socket.h&gt; typedef unsigned short int sa_family_t; // ipv4使用 struct sockaddr{ sa_family_t sa_family; char sa_data[4]; }; // ipv6使用 struct sockaddr_storage{ sa_family_t sa_family; unsigned long int __ss_align; // 字节对齐用 char __ss_padding[128 - sizeof(__ss_align)]; }; sa_family成员是地址族类型（sa_family_t）的变量，地址族与协议族类型相对应，两者实际存储的值都是相同的，因此可以混用，常见的协议族和地址族如下： 协议族 地址族 描述 地址值含义 长度 PF_UNIX AF_UNIX Unix本地域协议族 文件的路径名 最长108字节 PF_INET AF_INET TCP/IPv4协议族 16位的端口号以及32位的ipv4地址 6字节 PF_INET6 AF_INET6 TCP/IPv6协议族 16位的端口号、32位流标识、128位的ipv6地址 26字节 专用socket地址 由于很多网络编程函数都是基于ipv4的，那时候使用的都是通用socket地址，为了兼容，现在的通用socket地址退化成了类似于void *的作用，专用socket地址使用sockaddr_in或者sockaddr_in6，那么只需要给API传入sockaddr_in或者sockaddr_in6即可，函数内部会自动把专用的地址类型转化为通用地址类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # define __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int)) #include&lt;netinet/in.h&gt; typedef unsigned int in_addr_t; typedef unsigned short in_port_t; struct in_addr{ in_addr_t s_addr; }; struct sockaddr_in{ sa_family_t sin_family; // 地址族 in_port_t sin_port; // 端口 struct in_addr sin_addr; // 地址 unsigned char sin_zero[sizeof(struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof(in_port_t) - sizeof(struct in_addr)]; // 填充 }; struct sockaddr_in6{ sa_family_t sin6_family; in_port_t sin6_port; uint32_t sin6_flow_info; // ipv6的flow table struct in6_addr sin6_addr; // 类似于in_addr uint32_t sin6_scope_id; // ipv6的scope id }; 常用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt; // 该头文件包含了上面两个头文件 /* 参数说明 domain - 表示协议族有：AF_INET、AF_INET6、AF_UNIX等 type - 表示通信过程中的协议类型，常见的有：SOCK_STREAM（流式协议）、SOCK_DGRAM（报式协议）等 protocol - 表示具体的协议，一般传入0，比方说对于SOCK_STREAM填0就表示默认使用TCP，对于SOCK_DGRAM填0表示默认使用UDP 返回值 - 为文件描述符(fd)，如果失败则返回-1 */ int socket(int domain, int type, int protocol); // 创建套接字 /* 参数说明 sockfd - 表示通过socket函数得到的fd sockaddr - 表示需要绑定的地址和端口 addrlen - 表示addr占用的内存大小 返回值 - 成功0，失败-1 */ int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 将fd与本地的IP和port进行绑定 /* 参数说明 sockfd - 同上 backlog - 表示未连接队列和已经连接队列和的最大值，如果超过这个最大值则放弃连接，已连接表示已经经过3次握手的，未连接表示还没完成3次握手，一般设置成5就可以 */ int listen(int sockfd, int backlog); // 监听有socket上有无客户端连接 /* 参数说明 sockfd - 同上 sockaddr - 记录了连接成功后客户端的地址信息 addrlen - 表示addr占用的内存大小（注意是以指针传递） 返回值 - 成功返回用于通信的fd（不同于监听连接的fd），失败返回-1 */ int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // 接收客户端连接 /* 参数说明 sockfd - 表示客户端用于通信的fd addr - 表示客户端要连接的服务端的地址信息 addrlen - 表示addr占用的内存大小 返回值 - 成功0，失败-1 */ int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 客户端连接服务器 ssize_t write(int fd, const void *buf, size_t count); // 写数据 sszie_t read(int fd, void *buf, size_t count); // 读数据 简单TCP服务端样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include&lt;iostream&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;cstring&gt; using namespace std; int main(){ // 1. 创建socket int lsnfd = socket(AF_INET, SOCK_STREAM, 0); // 使用ipv4和TCP协议创建socket if(lsnfd == -1){ // 意外处理 perror(&quot;socket create failed&quot;); return -1; } // 2. 绑定socket sockaddr_in saddr; // 创建专用socket地址 saddr.sin_family = AF_INET; // 或者使用PF_INET，都表示使用ipv4协议 saddr.sin_addr.s_addr = 0; // ip地址设置为本机（0.0.0.0）,或者使用INADDR_ANY来绑定所有网卡的ip地址 // 如果要使用指定IP地址则应该使用以下代码，将本机字节序转换为网络字节序 // inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;saddr.sin_addr_s_addr); saddr.sin_port = htons(9999); // 设置socket端口号为9999，并转换为网络字节序 int rt = bind(lsnfd, (sockaddr *)&amp;saddr, sizeof(saddr)); // 绑定 if(rt == -1){ // 意外处理 perror(&quot;bind failed&quot;); return -1; } // 3. 监听 rt = listen(lsnfd, 8); // 监听创建的socket，并且把两个监听队列的总和上限设置为8 if(rt == -1){ // 意外处理 perror(&quot;listen failed&quot;); return -1; } // 4. 接受客户端的连接 sockaddr_in cliaddr; // 用于接收客户端的地址信息 socklen_t sz = sizeof(cliaddr); int clifd = accept(lsnfd, (sockaddr *)&amp;cliaddr, &amp;sz); // 阻塞的，直到有客户端连接进来 if(clifd == -1){ // 意外处理 perror(&quot;accept from client failed&quot;); return -1; } // 5. 读取客户端地址信息 char cliip[16]; // IP地址字符串的最长字节数为16（4个大小为3字节的数字、3个1字节的点、1个字节的字符串结尾\\0） inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliip, sizeof(cliip)); // 将客户端收到的IP地址（网络字节序）转为本机字节序 unsigned short cliport = ntohs(cliaddr.sin_port); // 接收客户端的端口（网络字节序），并且转换为本机字节序 cout &lt;&lt; &quot;[Server] Accept a clinet connection which from &quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; endl; // 输出客户端地址和端口 // 6. 读取客户端的数据 char recvbuf[1024]; // 创建缓存 memset(recvbuf, 0, sizeof(recvbuf)); int len = read(clifd, recvbuf, sizeof(recvbuf)); // 从accept到的客户端fd读取数据 if(len == -1){ // 意外处理 perror(&quot;read failed&quot;); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; &quot;[Server] Receive a message from client (&quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;) : &quot; &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; &quot;[Server] client (&quot; &lt;&lt; cliip &lt;&lt; &quot;:&quot; &lt;&lt; cliport &lt;&lt; &quot;) disconnect&quot; &lt;&lt; endl; } // 7. 给客户端返回数据 char msg[] = &quot;server has received your message&quot;; rt = write(clifd, msg, sizeof(msg)); // 8. 关闭文件描述符（只通信一次就退出） close(clifd); close(lsnfd); return 0; } 简单TCP客户端样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include&lt;iostream&gt; #include&lt;arpa/inet.h&gt; #include&lt;unistd.h&gt; #include&lt;cstring&gt; using namespace std; int main(){ // 1. 创建socket int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1){ perror(&quot;create socket failed&quot;); return -1; } // 2. 连接服务器 sockaddr_in saddr; saddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.85.128&quot;, &amp;saddr.sin_addr.s_addr); // 设置服务器ip地址 saddr.sin_port = htons(9999); // 设置服务器端口 int rt = connect(fd, (sockaddr*)&amp;saddr, sizeof(saddr)); if(rt == -1){ perror(&quot;connect failed&quot;); return -1; } // 3. 给服务器发送数据 char msg[] = &quot;Hello!&quot;; write(fd, msg, sizeof(msg)); // 4. 读取服务器返回的数据 char recvbuf[1024]; memset(recvbuf, 0, sizeof(recvbuf)); int len = read(fd, recvbuf, sizeof(recvbuf)); if(len == -1){ // 意外处理 perror(&quot;read failed&quot;); return -1; } else if(len &gt; 0){ // 表示有数据读取 cout &lt;&lt; &quot;[Client] Receive a message from server : &quot; &lt;&lt; recvbuf &lt;&lt; endl; } else if(len == 0){ // 表示客户端断开连接 cout &lt;&lt; &quot;[Client] Server closed&quot; &lt;&lt; endl; } // 5. 关闭文件描述符 close(fd); return 0; } I/O多路复用 I/O多路复用又称I/O多路转接，I/O多路复用可以让程序同时监听多个文件描述符(file descriptor)，从而提高程序的性能。Linux下实现I/O多路复用的API有select、poll和epoll。 常见的I/O模型有： 阻塞IO模型（Blocking I/O, BIO） 程序阻塞等待数据，有数据就去处理，没数据就在等待。 优点：不占用CPU的时间片 缺点：同一时刻只能处理一个，效率低 如果有多个数据需要处理，那么就要通过多进程或者多线程的方式来处理。 缺点：创建线程或者进程调度占用内存资源，线程或者进程的调度占用CPU资源 非阻塞IO模型（Non-blocking I/O, NIO） 程序不阻塞等待数据，但是需要轮询（会使用到系统调用），每隔一小段时间去查询是否有数据进来，有就去处理。如果需要处理的数据有很多，即有多个客户端连接到服务器，那么轮询会大量消耗系统资源。 优点：提高程序的执行效率 缺点：需要占用更多CPU和系统资源 IO多路复用模型 I/O多路复用则是把查询交给了内核去做，让内核通知用户，有什么数据需要处理。I/O多路复用实现有select、poll和epoll，简单来说select和poll只通知有数据到达了，但是不知道是哪些数据到达了，需要用户去轮询，epoll则会告知哪些数据到达了，用户直接去读取即可。 信号驱动IO模型 信号驱动不再使用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（使用系统调用sigaction来发出SIGIO信号），然后用户可以去做别的事，不用阻塞。当内核数据准备好后，再通过SIGIO信号通知用户，然后用户再去读数据。 异步IO模型（Asynchronous I/O, AIO） 前面的模型每当有数据需要读取时，都会发生数据读取时产生的阻塞，因为用户需要从内核空间拷贝到用户空间，因此都不是异步I/O。异步I/O模型实现了IO全流程的非阻塞，用户发出系统调用后，直接返回去处理自己的事情，等内核数据准备好，将数据拷贝到用户空间，发送信号通知用户IO操作执行完毕。 I/O多路复用 API select select API select使用流程： 调用select，监听列表中的文件描述符，直到列表中一个文件描述符或者多个文件描述符进行I/O操作时，select才返回（select是阻塞的，对文件描述符的操作是由内核完成的） 返回时，select会告诉有多少文件描述符需要操作 select工作流程：（结合API） fd_set会从用户空间拷贝到内核空间，然后遍历fd_set的每个标志位来判断是否要监听，如果有文件描述符变化了，那么会把更改过后的fd_set再拷贝到用户空间，用户也需要遍历fd_set的每个标志位来判断是否要操作数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include&lt;sys/time.h&gt; #include&lt;sys/types.h&gt; #include&lt;unistd.h&gt; /* fd_set typedef long int __fd_mask; struct fd_set{ __fd_mask __fds_bits[__FD_SETSIZE / _NFDBITS]; }; sizeof(fd_set) = 128 // 占用了1024位 */ /*timeval struct timeval{ long tv_sec; // 秒 long tv_usec; // 微秒 }; */ /* 参数说明 nfds - 委托内核检测的最大文件描述符的值再加上1 readfds - 委托内核检测文件描述符是否有读操作的集合（检测读缓冲区有没有数据）,fd_set类型可以看成是一个很大的整数，里面每一位（标志位）都表示一个fd，0表示不需要检测的fd，1表示需要检测的fd，由于是个指针，这个参数也会返回内核检测到的可以读取的fd的信息（可以读标志位为1，否则为0） writefds - 委托内核文件描述符是否有写操作的集合（检测写缓冲区是否满了，满了标志位为0，没满标志位为1） exceptfds - 检测发生异常的文件描述符的集合 timeout - 设置超时时间，值为NULL为永久阻塞直到检测fd有变化，值为0表示不阻塞直接返回，值大于0表示阻塞对应时间 返回值 - -1表示失败, 大于等于0表示检测的集合中有对应的文件描述符发生了变化 */ int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); // 将set中fd对应的标志位，置为0 void FD_CLR(int fd, fd_set *set); // 判断set中fd对应的标志位是0还是1并返回 int FD_ISSET(int fd, fd_set *set); // 将set中fd对应的标志位，置为1 void FD_SET(int fd, fd_set *set); // 将set中所有标志位全部初始化为0 voif FD_ZERO(fd_set *set); select使用样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // int lfd = socket(...); // ... // bind(...); // listen(...); // 创建fd_set，存储需要检测文件描述符 fd_set rdset, tmp; // 因为内核会更改fd_set，因此可以把tmp交给内核修改，然后使用rdset复原即可 FD_ZERO(&amp;rdset); // 初始化为0 FD_SET(lfd, &amp;rdset); // 把监听fd设置为1 int maxfd = lfd; // 初始化最大的fd while(1){ tmp = rdset; int rt = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); // 阻塞到有数据进来（或者说是有客户端连接） if(rt == -1){ // 意外处理 perror(&quot;select failed&quot;); exit(-1); } else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(FD_ISSET(lfd, &amp;tmp)){ // 判断lfd是否有数据可操作（或者说是有客户端连接） // int cfd = accept(...); FD_SET(cfd, &amp;rdset); // 将新的fd加入集合中 maxfd = max(maxfd, cfd); // 更新最大的fd } } for(int i = lfd + 1; i &lt;= maxfd; i ++){ // 轮询rdset，lfd是第一个创建的fd所以初始值可以直接赋为lfd + 1 if(FD_ISSET(i, &amp;tmp)){ // 判断fd是否有数据来了 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(i, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(&quot;read failed&quot;); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; FD_CLR(i, &amp;rdset); } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } } 以上的例子可以看到并没有使用到多线程和多进程就可以处理多个客户端的数据。 select 的缺陷 每次都需要把fd_set从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历fd_set的每个标志位，时间复杂度是O(n)的。 select支持的文件描述符数量太小了，只有1024个。 fd_set不能重用，每次都需要重置。 poll poll API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include&lt;poll.h&gt; struct pollfd{ int fd; // 委托内核检测的文件描述符 short events; // 委托内核检测fd的什么事件（用户设置的变量） short revents; // fd实际发生的事件（内核操作的变量） }; /* 参数介绍 fds - 是一个pollfd的结构体数组指针，这是一个需要检测的fd的集合 nfds - 表示pollfd结构体数组中最后一个有效元素的下标加1 timeout - 阻塞时长，-1表示阻塞（直到fds有变化），0表示不阻塞，大于0表示阻塞对应的时长(ms) 返回值 - -1表示失败，大于等于0表示成功，表示有对应个fd发生变化 */ int poll(struct pollfd *fds, nfds_t nfds, int timeout); pollfd中的events和revents的取值有： 事件 值 作为events的值 作为revents的值 说明 读事件 POLLINPOLLRDNORMPOLLRDBANDPOLLPRI √√√√ √√√√ 普通或优先带数据可读普通数据可读优先级带数据可读高优先级数据可读 写事件 POLLOUTPOLLWRNORMPOLLWRBAND √√√ √√√ 普通或优先带数据可写普通数据可写优先级带数据可写 错误事件 POLLERRPOLLHUPPOLLNVAL   √√√ 发生错误发生挂起描述不是打开的文件 比较常用的读事件的值为POLLIN，写事件的值为POLLOUT，如果既要检测读事件也要检测写事件可以写成POLLIN | POLLOUT。 poll使用样例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // int lfd = socket(...); // ... // bind(...); // listen(...); const int FDSIZE = 1024; pollfd fds[FDSIZE]; // 数组大小可以任意指定，不一定是1024 for(int i = 0; i &lt; FDSIZE; i ++){ // 初始化pollfd结构体数组 fds[i].fd = -1; fds[i].events = POLLIN; } fds[0].fd = lfd; // 监听fd加入数组中 int nfds = 0; // 记录有效fd的最大下标，为了方便实现直接记录数组的最大下标即可 while(1){ int rt = poll(fds, nfds + 1, -1); // 阻塞，等待数据进来（或等待客户端连接） if(rt == -1){ // 意外处理 perror(&quot;poll failed&quot;); exit(-1); } else if(rt == 0){ // 没有检测到fd改变 continue; } else if(rt &gt; 0){ // 检测到了某些fd变化了 if(fds[0].revents &amp; POLLIN){ // 表示监听文件描述符lfd的revents中存在POLLIN事件（位运算） // int cfd = accept(...); // 找pollfd数组中空闲位置插入新加入的fd（有新的客户端连接） for(int i = 1; i &lt; FDSIZE; i ++){ if(i &gt; nfds) nfds = i; // 记录最大下标（不一定是有效） if(fds[i].fd == -1){ fds[i].fd = cfd; fds[i].events = POLLIN; break; } } } } for(int i = 1; i &lt;= nfds; i ++){ // 轮询fds，0是监听fd，因此需要从1开始遍历 if(fds[i].revents &amp; POLLIN){ // 判断fds元素的revents中是否存在POLLIN事件（位运算） char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(fds[i].fd, buf, sizeof(buf)); if(len == -1){ // 读取失败 perror(&quot;read failed&quot;); exit(-1); } else if (len == 0){ // 客户端断开连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; close(fds[i].fd); // 关闭对应fd fds[i].fd = -1; // 将pollfd数组对应元素的fd置为-1，空出位置 } else if(len &gt; 0){ // 读到了数据 cout &lt;&lt; buf &lt;&lt; endl; // write(...); // 返回数据 } } } } poll的缺陷 需要把pollfd数组从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。 每次需要遍历pollfd数组的每个revents来判断是否有数据变化，时间复杂度是O(n)的。 epoll epoll API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include&lt;sys/epoll.h&gt; /* struct eventpoll{ //... struct rb_root rbr; // 红黑树根节点，红黑树中存储需要检测的文件描述符 struct list_head rdlist; // 就绪队列双链表，存储有数据变化的文件描述符 // ... }; */ /* 参数说明 size - 目前没有意义了，随便写一个大于0的数 返回值 - 失败返回-1，成功返回文件描述符fd，用于操控内核空间中的实例(eventpoll类型) */ int epoll_create(int size); // 在内核空间中创建实例(eventpoll类型) typedef union epoll_data{ void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; strut epoll_event{ uint32_t events; // 需要检测的epoll事件（EPOLL_IN、EPOLLOUT、EPOLLERR、EPOLLET等） epoll_data_t data; // 存储用户的数据信息，一般只存fd }; /* 参数介绍 epfd - 通过epoll_create创建出来的eventpoll实例对应的fd op - 对eventpoll实例的操作选项，比如添加fd、删除fd、修改fd检测的操作等（分别对应EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD） fd - 需要进行操作的文件描述符 event - 记录了fd需要检测的事件（删除操作输入NULL即可） 返回值 - 成功返回0，失败返回-1 */ int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 操作内核空间的eventpoll实例 /* 参数介绍 epfd - 同上 events - 存储所有发生了变化的fd maxevents - events数组的大小 timeout - 阻塞时间，-1表示阻塞（直到有fd发生变化），0表示不阻塞，大于表示要阻塞的时长(ms) 返回值 - 成功返回发生变化的fd的个数，失败返回-1 */ int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); // 检测是否有发生变化的fd，从内核空间的就绪队列中拷贝出来，存储在events中 epoll的两种工作模式 水平触发（Level Triggered, LT） LT是默认的工作方式，同时支持阻塞和非阻塞的socket，在这种工作模式中，内核会不断通知用户是否有文件描述符就绪了，然后用户可以对就绪的文件描述符进行IO操作，如果用户没有进行操作的话，内核还是会继续通知用户。 边缘触发（Edge Triggered, ET） ET是较为高速的工作方式，只支持非阻塞的socket，当有文件描述符变成就绪时，内核只会通知用户一次（only once），后续不会为这个文件描述符向用户发送就绪通知，直到用户操作了文件描述符使得这个文件描述符不再是就绪状态。 比如有个fd就绪了有8个字节需要读取，用户只读取了2个字节，剩余6个字节没有读取，在下次内核发现这个fd里面还有数据没读的话，在ET模式下内核就不会再通知用户（直到又有新数据到来了，更改了该fd的就绪状态，但是也是会按照缓冲区的顺序读取数据），在LT模式下内核就会去通知用户。 ET模式减少了内核通知用户的次数，因此效率比LT模式要高，但是epoll在ET模式的时候，必须使用非阻塞的套接字接口，因为内核只通知用户一次，用户应该一次把数据读完，所以就不能使用阻塞的读写操作，否则就会导致进程或者线程饿死（因为需要阻塞等待数据的读或者写）。 epoll使用案例 LT模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // int lfd = socket(...); // ... // bind(...); // listen(...); int epfd = epoll_create(100); // 创建eventpoll实例，参数随便写个大于0的数 // 将监听fd添加到eventpoll实例中 epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); const int FDSIZE = 1024; epoll_event epevs[FDSIZE]; // 接收从内核检测到的fd集合，大小无限制 while(1){ // 阻塞等待数据来（或等客户端连接） // 返回值是发生变化fd的数目 // 由于是水平触发，如果数据没有读完，epoll_wait会把没有读完的fd放入就绪队列中再返回 int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ // 失败处理 perror(&quot;epoll wait failed&quot;); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd; if(curfd == lfd){ // 判断是否是监听fd，如果为真说明有客户端连接 // ... // int cfd = accept(...); // 将接收到的客户端fd加入内核检测的fd集合中 epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ // 说明是客户端fd，判断是读操作的情况 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ // 错误处理 perror(&quot;cfd read failed&quot;); exit(-1); } else if(len == 0){ // 客户端关闭连接 cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); //从eventpoll实例中删除该fd close(curfd); } else if(len &gt; 0){ // 读到数据了进行对应处理 cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } } else if(epevs[i].events &amp; EPOLLOUT){ //客户端fd写操作的情况 // 写操作逻辑 } } } // 关闭创建出来的lfd和epfd close(lfd); close(epfd); ET模式 相比于LT模式，ET需要多更改一些设置，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 // int lfd = socket(...); // ... // bind(...); // listen(...); int epfd = epoll_create(100); epoll_event epev; epev.events = EPOLLIN; // 监听fd应该为水平触发 epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); const int FDSIZE = 1024; epoll_event epevs[FDSIZE]; while(1){ // 由于是边缘触发，内核只通知一次 // 如果数据没读完，那么后面的数据就无法读到（需要一次性读完） int rt = epoll_wait(epfd, epevs, FDSIZE, -1); if(rt == -1){ perror(&quot;epoll wait failed&quot;); exit(-1); } for(int i = 0; i &lt; rt; i ++){ int curfd = epevs[i].data.fd; if(curfd == lfd){ // ... // int cfd = accept(...); // 设置cfd为非阻塞，以用于后续非阻塞读写 // 头文件需要额外添加fcntl.h int flag = fcntl(cfd, F_GETFL); // 得到cfd的flag fcntl(cfd, F_SETFL, flag | O_NONBLOCK); // 设置flag为非阻塞 // 设置为边缘触发 // // --------------------------------// epev.events = EPOLLIN | EPOLLET; // --------------------------------// epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); } else if(epevs[i].events &amp; EPOLLIN){ /* 无法一次性读取数据 char buf[1024]; memset(buf, 0, sizeof(buf)); int len = read(curfd, buf, sizeof(buf)); if(len == -1){ perror(&quot;cfd read failed&quot;); exit(-1); } else if(len == 0){ cout &lt;&lt; &quot;client closed&quot; &lt;&lt; endl; epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); } else if(len &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // ... // write(...); } */ // 一次性读取所有数据，使用循环来分别读取出来 char buf[1024]; memset(buf, 0, sizeof(bug)); int len = 0; while( (len = read(curfd, buf, sizeof(buf))) &gt; 0){ cout &lt;&lt; buf &lt;&lt; endl; // 读操作逻辑 // write(...) } if(len == 0){ cout &lt;&lt; &quot;clinet closed&quot; &lt;&lt; endl; } else if(len == -1){ // 需要额外头文件errno.h if(errno == EAGAIN){ // 数据读完可能产生的错误 // 处理逻辑 } else{ perror(&quot;read failed&quot;); exit(-1); } } } else if(epevs[i].events &amp; EPOLLOUT){ // 写操作逻辑 } } } close(lfd); close(epfd); 参考资料 [1]. 牛客网——C++高薪面试项目 [2]. 掘金——看一遍就理解：IO模型详解","headline":"Linux网络编程","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},"url":"/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}</script><title>Linux网络编程 | XopowoYpa</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="XopowoYpa"><meta name="application-name" content="XopowoYpa"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar/img.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">XopowoYpa</a></div><div class="site-subtitle font-italic">sharing computer tech and science</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/XopowoYpa" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Linux网络编程</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Linux网络编程</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1659962251" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-08-08 </em> </span> <span> 更新于 <em class="" data-ts="1660032268" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-08-09 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://twitter.com/username">XopowoYpa</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7857 字"> <em>43 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="引言">引言</h1><p>本文主要介绍了Linux环境下的网络编程，主要使用到了<code class="language-plaintext highlighter-rouge">socket</code>、<code class="language-plaintext highlighter-rouge">select</code>、<code class="language-plaintext highlighter-rouge">poll</code>、<code class="language-plaintext highlighter-rouge">epoll</code>等API，并且给出相关介绍与使用样例。</p><h1 id="字节序">字节序</h1><p>字节序是大于一个字节类型的数据在内存中存放的顺序，<strong>字节序分为大端字节序和小端字节序（小端存储和大端存储）</strong>，大端字节序是指一个整数的最高位字节存储在内存的低地址处，低位字节存储在内存的高位地址，小端反之。</p><p>举例：</p><p>假设有数据<code class="language-plaintext highlighter-rouge">0x 01 02 03 04</code>（4个字节），同时假设内存地址增长方向是从左往右的，那么如果<strong>按照小端存储则有</strong>：</p><p><code class="language-plaintext highlighter-rouge">0x04 03 02 01</code></p><p><strong>按照大端存储则有</strong>：</p><p><code class="language-plaintext highlighter-rouge">0x01 02 03 04</code></p><p>判断机器是大端还是小端：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">union</span><span class="p">{</span>
	<span class="kt">short</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 2个字节</span>
    <span class="kt">char</span> <span class="n">bytes</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">)];</span> <span class="c1">// char[2] 2个字节</span>
<span class="p">}</span> <span class="n">test</span><span class="p">;</span>

<span class="n">test</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="mh">0x0102</span><span class="p">;</span>

<span class="k">if</span><span class="p">((</span><span class="n">test</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"大端存储"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="n">test</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"小端存储"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><h1 id="字节序转换-api">字节序转换 API</h1><p>如果格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端会错误解释数据。解决的办法是：发送端总是以大端序发送数据，接收端根据自己的情况将大端序转换为自己需要的字节序。</p><p>TCP/IP中规定了一种数据表示格式，即大端序，从而保证数据在不同主机之间传输可以被正确解释。</p><p>Socket提供了封装好的转换API：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="c1">// h表示 host，n表示network，s表示unsigned short，l表示unsigned int</span>
<span class="c1">// 转换端口用</span>
<span class="kt">uint16_t</span> <span class="nf">htons</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">hostshort</span><span class="p">);</span> <span class="c1">// 主机字节序转网络字节序，返回值是大端的</span>
<span class="kt">uint16_t</span> <span class="nf">ntohs</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">netshort</span><span class="p">);</span>	<span class="c1">// 反之，返回值根据主机而定</span>
<span class="c1">// 转换ip用</span>
<span class="kt">uint32_t</span> <span class="nf">htonl</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">hostlong</span><span class="p">);</span> <span class="c1">// 主机字节序转网络字节序，返回值是大端的</span>
<span class="kt">uint32_t</span> <span class="nf">ntohl</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">netlong</span><span class="p">);</span> <span class="c1">// 反之，返回值根据主机而定</span>
</pre></table></code></div></div><h1 id="ip地址转换-api">IP地址转换 API</h1><p>通常我们喜欢用可读性好的字符串来表示ip地址，比如<code class="language-plaintext highlighter-rouge">127.0.0.1</code>，实际上在机器中存储的是一个无符号整型，把它用来表示地址，因此需要互相转换，具体API如下（比较旧的API）：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_addr_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">in_addr</span><span class="p">{</span>
    <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 十进制形式ipv4地址字符串cp转换为ipv4网络字节序的数并返回</span>
<span class="n">in_addr_t</span> <span class="nf">inet_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span> 
<span class="c1">// 十进制形式ipv4地址字符串cp，转换为ipv4网络字节序列的地址inp</span>
<span class="c1">// 返回1表示转换成功，0表示输入非法</span>
<span class="kt">int</span> <span class="nf">inet_aton</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in_addr</span> <span class="o">*</span><span class="n">inp</span><span class="p">);</span> 
<span class="c1">// ipv4网络字节序地址转换为十进制形式ipv4地址字符串</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">inet_ntoa</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr_in</span><span class="p">)</span>
</pre></table></code></div></div><p><strong>最新的API（ipv4和ipv6都可以使用）：</strong></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="c1">// 命名中p表示十进制IP字符串，n表示netaddr即网络字节序的整数</span>
<span class="cm">/* 参数说明
af - 表示协议类型（af：AF_INET、AF_INET6）
src - 表示十进制形式IP地址
dst - 表示转换完成后的网络字节序整数
返回值 - 1表示转换成功，0表示输入非法，-1表示协议非法
*/</span>
<span class="kt">int</span> <span class="nf">inet_pton</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">);</span>

<span class="c1">// 反过程，size表示可用的字节数的大小，即表示dst的size</span>
<span class="c1">// 返回值表示转换后的字符串的地址，和dst是相同值</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">size</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="socket-api">socket API</h1><p>socket提供了一套网络的API，用户可以通过socket来传输数据。通用socket地址里面封装了第一层的接口，专用socket地址封装了第二层的接口，用户主要是通过专用socket接口来使用socket。</p><h2 id="通用socket地址"><span class="mr-2">通用socket地址</span><a href="#通用socket地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>socket地址为一个结构体，其定义如下：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">sa_family_t</span><span class="p">;</span>
<span class="c1">// ipv4使用</span>
<span class="k">struct</span> <span class="nc">sockaddr</span><span class="p">{</span>
    <span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>
<span class="c1">// ipv6使用</span>
<span class="k">struct</span> <span class="nc">sockaddr_storage</span><span class="p">{</span>
    <span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">__ss_align</span><span class="p">;</span> <span class="c1">// 字节对齐用</span>
    <span class="kt">char</span> <span class="n">__ss_padding</span><span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__ss_align</span><span class="p">)];</span>
<span class="p">};</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">sa_family</code>成员是地址族类型（<code class="language-plaintext highlighter-rouge">sa_family_t</code>）的变量，地址族与协议族类型相对应，两者实际存储的值都是相同的，因此可以混用，常见的协议族和地址族如下：</p><div class="table-wrapper"><table><thead><tr><th>协议族<th>地址族<th>描述<th>地址值含义<th>长度<tbody><tr><td>PF_UNIX<td>AF_UNIX<td>Unix本地域协议族<td>文件的路径名<td>最长108字节<tr><td>PF_INET<td>AF_INET<td>TCP/IPv4协议族<td>16位的端口号以及32位的ipv4地址<td>6字节<tr><td>PF_INET6<td>AF_INET6<td>TCP/IPv6协议族<td>16位的端口号、32位流标识、128位的ipv6地址<td>26字节</table></div><h2 id="专用socket地址"><span class="mr-2">专用socket地址</span><a href="#专用socket地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>由于很多网络编程函数都是基于ipv4的，那时候使用的都是通用socket地址，为了兼容，现在的通用socket地址退化成了类似于<code class="language-plaintext highlighter-rouge">void *</code>的作用，专用socket地址使用<code class="language-plaintext highlighter-rouge">sockaddr_in</code>或者<code class="language-plaintext highlighter-rouge">sockaddr_in6</code>，那么只需要给API传入<code class="language-plaintext highlighter-rouge">sockaddr_in</code>或者<code class="language-plaintext highlighter-rouge">sockaddr_in6</code>即可，函数内部会自动把专用的地址类型转化为通用地址类型。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp"># define __SOCKADDR_COMMON_SIZE (sizeof(unsigned short int))
#include</span><span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_addr_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">in_port_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">in_addr</span><span class="p">{</span>
    <span class="n">in_addr_t</span> <span class="n">s_addr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">{</span>
    <span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="c1">// 地址族</span>
    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span>	<span class="c1">// 端口</span>
    <span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="c1">// 地址</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">)</span> <span class="o">-</span> <span class="n">__SOCKADDR_COMMON_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">in_port_t</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="p">)];</span> <span class="c1">// 填充</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sockaddr_in6</span><span class="p">{</span>
    <span class="n">sa_family_t</span> <span class="n">sin6_family</span><span class="p">;</span>
    <span class="n">in_port_t</span> <span class="n">sin6_port</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">sin6_flow_info</span><span class="p">;</span> <span class="c1">// ipv6的flow table</span>
    <span class="k">struct</span> <span class="n">in6_addr</span> <span class="n">sin6_addr</span><span class="p">;</span> <span class="c1">// 类似于in_addr</span>
    <span class="kt">uint32_t</span> <span class="n">sin6_scope_id</span><span class="p">;</span> <span class="c1">// ipv6的scope id</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="常用api"><span class="mr-2">常用API</span><a href="#常用api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="c1"> // 该头文件包含了上面两个头文件</span><span class="cp">
</span>
<span class="cm">/* 参数说明
domain - 表示协议族有：AF_INET、AF_INET6、AF_UNIX等
type - 表示通信过程中的协议类型，常见的有：SOCK_STREAM（流式协议）、SOCK_DGRAM（报式协议）等
protocol - 表示具体的协议，一般传入0，比方说对于SOCK_STREAM填0就表示默认使用TCP，对于SOCK_DGRAM填0表示默认使用UDP
返回值 - 为文件描述符(fd)，如果失败则返回-1
*/</span>
<span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span> <span class="c1">// 创建套接字</span>

<span class="cm">/* 参数说明
sockfd - 表示通过socket函数得到的fd
sockaddr - 表示需要绑定的地址和端口
addrlen - 表示addr占用的内存大小
返回值 - 成功0，失败-1
*/</span>
<span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span> <span class="c1">// 将fd与本地的IP和port进行绑定</span>

<span class="cm">/* 参数说明
sockfd - 同上
backlog - 表示未连接队列和已经连接队列和的最大值，如果超过这个最大值则放弃连接，已连接表示已经经过3次握手的，未连接表示还没完成3次握手，一般设置成5就可以
*/</span>
<span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span> <span class="c1">// 监听有socket上有无客户端连接</span>

<span class="cm">/* 参数说明
sockfd - 同上
sockaddr - 记录了连接成功后客户端的地址信息
addrlen - 表示addr占用的内存大小（注意是以指针传递）
返回值 - 成功返回用于通信的fd（不同于监听连接的fd），失败返回-1
*/</span>
<span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span> <span class="c1">// 接收客户端连接</span>

<span class="cm">/* 参数说明
sockfd - 表示客户端用于通信的fd
addr - 表示客户端要连接的服务端的地址信息
addrlen - 表示addr占用的内存大小
返回值 - 成功0，失败-1
*/</span>
<span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span> <span class="c1">// 客户端连接服务器</span>

<span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span> <span class="c1">// 写数据</span>
<span class="n">sszie_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>	<span class="c1">// 读数据</span>
</pre></table></code></div></div><h2 id="简单tcp服务端样例"><span class="mr-2">简单TCP服务端样例</span><a href="#简单tcp服务端样例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="c1">// 1. 创建socket</span>
    <span class="kt">int</span> <span class="n">lsnfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 使用ipv4和TCP协议创建socket</span>

    <span class="k">if</span><span class="p">(</span><span class="n">lsnfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"socket create failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// 2. 绑定socket</span>
    <span class="n">sockaddr_in</span> <span class="n">saddr</span><span class="p">;</span> <span class="c1">// 创建专用socket地址</span>
    <span class="n">saddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span> <span class="c1">// 或者使用PF_INET，都表示使用ipv4协议</span>
    <span class="n">saddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ip地址设置为本机（0.0.0.0）,或者使用INADDR_ANY来绑定所有网卡的ip地址</span>
    <span class="c1">// 如果要使用指定IP地址则应该使用以下代码，将本机字节序转换为网络字节序</span>
    <span class="c1">// inet_pton(AF_INET, "127.0.0.1", &amp;saddr.sin_addr_s_addr);</span>
    <span class="n">saddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">9999</span><span class="p">);</span> <span class="c1">// 设置socket端口号为9999，并转换为网络字节序</span>

    <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">lsnfd</span><span class="p">,</span> <span class="p">(</span><span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="p">));</span> <span class="c1">// 绑定</span>

    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"bind failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 监听</span>
    <span class="n">rt</span> <span class="o">=</span> <span class="n">listen</span><span class="p">(</span><span class="n">lsnfd</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// 监听创建的socket，并且把两个监听队列的总和上限设置为8</span>

    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"listen failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 4. 接受客户端的连接</span>
    <span class="n">sockaddr_in</span> <span class="n">cliaddr</span><span class="p">;</span> <span class="c1">// 用于接收客户端的地址信息 </span>
    <span class="n">socklen_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">clifd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">lsnfd</span><span class="p">,</span> <span class="p">(</span><span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sz</span><span class="p">);</span> <span class="c1">// 阻塞的，直到有客户端连接进来</span>

    <span class="k">if</span><span class="p">(</span><span class="n">clifd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"accept from client failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 5. 读取客户端地址信息</span>
    <span class="kt">char</span> <span class="n">cliip</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span> <span class="c1">// IP地址字符串的最长字节数为16（4个大小为3字节的数字、3个1字节的点、1个字节的字符串结尾\0）</span>
    <span class="n">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">,</span> <span class="n">cliip</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliip</span><span class="p">));</span> <span class="c1">// 将客户端收到的IP地址（网络字节序）转为本机字节序</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">cliport</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">);</span> <span class="c1">// 接收客户端的端口（网络字节序），并且转换为本机字节序</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Server] Accept a clinet connection which from "</span> <span class="o">&lt;&lt;</span> <span class="n">cliip</span> <span class="o">&lt;&lt;</span> <span class="s">":"</span> <span class="o">&lt;&lt;</span> <span class="n">cliport</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出客户端地址和端口</span>

    <span class="c1">// 6. 读取客户端的数据</span>
    <span class="kt">char</span> <span class="n">recvbuf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">// 创建缓存</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">clifd</span><span class="p">,</span> <span class="n">recvbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">));</span> <span class="c1">// 从accept到的客户端fd读取数据</span>
    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>  <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"read failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 表示有数据读取</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Server] Receive a message from client ("</span> <span class="o">&lt;&lt;</span> <span class="n">cliip</span> <span class="o">&lt;&lt;</span> <span class="s">":"</span> <span class="o">&lt;&lt;</span> <span class="n">cliport</span> <span class="o">&lt;&lt;</span> <span class="s">") : "</span> <span class="o">&lt;&lt;</span> <span class="n">recvbuf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 表示客户端断开连接</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Server] client ("</span> <span class="o">&lt;&lt;</span> <span class="n">cliip</span> <span class="o">&lt;&lt;</span> <span class="s">":"</span> <span class="o">&lt;&lt;</span> <span class="n">cliport</span> <span class="o">&lt;&lt;</span> <span class="s">") disconnect"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 7. 给客户端返回数据</span>
    <span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"server has received your message"</span><span class="p">;</span>
    <span class="n">rt</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">clifd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>

    <span class="c1">// 8. 关闭文件描述符（只通信一次就退出）</span>
    <span class="n">close</span><span class="p">(</span><span class="n">clifd</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">lsnfd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="简单tcp客户端样例"><span class="mr-2">简单TCP客户端样例</span><a href="#简单tcp客户端样例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="c1">// 1. 创建socket</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"create socket failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. 连接服务器</span>
    <span class="n">sockaddr_in</span> <span class="n">saddr</span><span class="p">;</span>
    <span class="n">saddr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="s">"192.168.85.128"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span> <span class="c1">// 设置服务器ip地址</span>
    <span class="n">saddr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">9999</span><span class="p">);</span> <span class="c1">// 设置服务器端口</span>

    <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="p">));</span>

    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"connect failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 给服务器发送数据</span>
    <span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello!"</span><span class="p">;</span> 
    <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>

    <span class="c1">// 4. 读取服务器返回的数据</span>
    <span class="kt">char</span> <span class="n">recvbuf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">recvbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">recvbuf</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"read failed"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 表示有数据读取</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Client] Receive a message from server : "</span> <span class="o">&lt;&lt;</span> <span class="n">recvbuf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 表示客户端断开连接</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[Client] Server closed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 5. 关闭文件描述符</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="io多路复用">I/O多路复用</h1><p>I/O多路复用又称I/O多路转接，<strong>I/O多路复用可以让程序同时监听多个文件描述符(file descriptor)，从而提高程序的性能</strong>。Linux下实现I/O多路复用的API有<code class="language-plaintext highlighter-rouge">select</code>、<code class="language-plaintext highlighter-rouge">poll</code>和<code class="language-plaintext highlighter-rouge">epoll</code>。</p><p>常见的I/O模型有：</p><ul><li><p><strong>阻塞IO模型</strong>（Blocking I/O, BIO）</p><p>程序阻塞等待数据，有数据就去处理，没数据就在等待。</p><ul><li>优点：不占用CPU的时间片<li>缺点：同一时刻只能处理一个，效率低</ul><p>如果有多个数据需要处理，那么就要通过多进程或者多线程的方式来处理。</p><ul><li>缺点：创建线程或者进程调度占用内存资源，线程或者进程的调度占用CPU资源</ul><li><p><strong>非阻塞IO模型</strong>（Non-blocking I/O, NIO）</p><p>程序不阻塞等待数据，但是需要轮询（会使用到系统调用），每隔一小段时间去查询是否有数据进来，有就去处理。如果需要处理的数据有很多，即有多个客户端连接到服务器，那么轮询会大量消耗系统资源。</p><ul><li>优点：提高程序的执行效率<li>缺点：需要占用更多CPU和系统资源</ul><li><p><strong>IO多路复用模型</strong></p><p>I/O多路复用则是把查询交给了内核去做，让内核通知用户，有什么数据需要处理。I/O多路复用实现有<code class="language-plaintext highlighter-rouge">select</code>、<code class="language-plaintext highlighter-rouge">poll</code>和<code class="language-plaintext highlighter-rouge">epoll</code>，简单来说<code class="language-plaintext highlighter-rouge">select</code>和<code class="language-plaintext highlighter-rouge">poll</code>只通知有数据到达了，但是不知道是哪些数据到达了，需要用户去轮询，<code class="language-plaintext highlighter-rouge">epoll</code>则会告知哪些数据到达了，用户直接去读取即可。</p><li><p><strong>信号驱动IO模型</strong></p><p>信号驱动不再使用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（使用系统调用<code class="language-plaintext highlighter-rouge">sigaction</code>来发出<code class="language-plaintext highlighter-rouge">SIGIO</code>信号），然后用户可以去做别的事，不用阻塞。当内核数据准备好后，再通过<code class="language-plaintext highlighter-rouge">SIGIO</code>信号通知用户，然后用户再去读数据。</p><li><p><strong>异步IO模型</strong>（Asynchronous I/O, AIO）</p><p>前面的模型每当有数据需要读取时，都会发生数据读取时产生的阻塞，因为用户需要从内核空间拷贝到用户空间，因此都不是异步I/O。异步I/O模型实现了IO全流程的非阻塞，用户发出系统调用后，直接返回去处理自己的事情，等内核数据准备好，将数据拷贝到用户空间，发送信号通知用户IO操作执行完毕。</p></ul><h1 id="io多路复用-api">I/O多路复用 API</h1><h2 id="select"><span class="mr-2">select</span><a href="#select" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="select-api"><span class="mr-2">select API</span><a href="#select-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>select使用流程：</p><ol><li>调用select，监听列表中的文件描述符，直到列表中一个文件描述符或者多个文件描述符进行I/O操作时，select才返回（select是阻塞的，对文件描述符的操作是由内核完成的）<li>返回时，select会告诉有多少文件描述符需要操作</ol><p>select工作流程：（结合API） <code class="language-plaintext highlighter-rouge">fd_set</code>会从<strong>用户空间</strong>拷贝到<strong>内核空间</strong>，然后遍历<code class="language-plaintext highlighter-rouge">fd_set</code>的每个标志位来判断是否要监听，如果有文件描述符变化了，那么会把更改过后的<code class="language-plaintext highlighter-rouge">fd_set</code>再拷贝到<strong>用户空间</strong>，用户也需要遍历<code class="language-plaintext highlighter-rouge">fd_set</code>的每个标志位来判断是否要操作数据。</p></blockquote><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;sys/time.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cm">/* fd_set
typedef long int __fd_mask;
struct fd_set{
	__fd_mask __fds_bits[__FD_SETSIZE / _NFDBITS];
};
sizeof(fd_set) = 128 // 占用了1024位
*/</span>

<span class="cm">/*timeval
struct timeval{
    long tv_sec; // 秒
    long tv_usec; // 微秒
};
*/</span>

<span class="cm">/* 参数说明
nfds - 委托内核检测的最大文件描述符的值再加上1
readfds - 委托内核检测文件描述符是否有读操作的集合（检测读缓冲区有没有数据）,fd_set类型可以看成是一个很大的整数，里面每一位（标志位）都表示一个fd，0表示不需要检测的fd，1表示需要检测的fd，由于是个指针，这个参数也会返回内核检测到的可以读取的fd的信息（可以读标志位为1，否则为0）
writefds - 委托内核文件描述符是否有写操作的集合（检测写缓冲区是否满了，满了标志位为0，没满标志位为1）
exceptfds - 检测发生异常的文件描述符的集合 
timeout - 设置超时时间，值为NULL为永久阻塞直到检测fd有变化，值为0表示不阻塞直接返回，值大于0表示阻塞对应时间
返回值 - -1表示失败, 大于等于0表示检测的集合中有对应的文件描述符发生了变化
*/</span>
<span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>

<span class="c1">// 将set中fd对应的标志位，置为0</span>
<span class="kt">void</span> <span class="nf">FD_CLR</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

<span class="c1">// 判断set中fd对应的标志位是0还是1并返回</span>
<span class="kt">int</span> <span class="nf">FD_ISSET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

<span class="c1">// 将set中fd对应的标志位，置为1</span>
<span class="kt">void</span> <span class="nf">FD_SET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>

<span class="c1">// 将set中所有标志位全部初始化为0</span>
<span class="n">voif</span> <span class="nf">FD_ZERO</span><span class="p">(</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="select使用样例"><span class="mr-2">select使用样例</span><a href="#select使用样例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="c1">// int lfd = socket(...);</span>
<span class="c1">// ...</span>
<span class="c1">// bind(...);</span>
<span class="c1">// listen(...);</span>

<span class="c1">// 创建fd_set，存储需要检测文件描述符</span>
<span class="n">fd_set</span> <span class="n">rdset</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// 因为内核会更改fd_set，因此可以把tmp交给内核修改，然后使用rdset复原即可</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdset</span><span class="p">);</span> <span class="c1">// 初始化为0</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdset</span><span class="p">);</span> <span class="c1">// 把监听fd设置为1</span>
<span class="kt">int</span> <span class="n">maxfd</span> <span class="o">=</span> <span class="n">lfd</span><span class="p">;</span> <span class="c1">// 初始化最大的fd</span>

<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
    
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">rdset</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">maxfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// 阻塞到有数据进来（或者说是有客户端连接）</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"select failed"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>	
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 没有检测到fd改变</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 检测到了某些fd变化了</span>
        <span class="k">if</span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">lfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">)){</span> <span class="c1">// 判断lfd是否有数据可操作（或者说是有客户端连接）</span>
            <span class="c1">// int cfd = accept(...);</span>
            <span class="n">FD_SET</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdset</span><span class="p">);</span> <span class="c1">// 将新的fd加入集合中</span>
            <span class="n">maxfd</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="n">cfd</span><span class="p">);</span> <span class="c1">// 更新最大的fd</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxfd</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span> <span class="c1">// 轮询rdset，lfd是第一个创建的fd所以初始值可以直接赋为lfd + 1</span>
        <span class="k">if</span><span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">)){</span> <span class="c1">// 判断fd是否有数据来了</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 读取失败</span>
                <span class="n">perror</span><span class="p">(</span><span class="s">"read failed"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 客户端断开连接</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"client closed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="n">FD_CLR</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdset</span><span class="p">);</span> 
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 读到了数据</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// write(...); // 返回数据</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</pre></table></code></div></div><p>以上的例子可以看到并没有使用到多线程和多进程就可以处理多个客户端的数据。</p><h3 id="select-的缺陷"><span class="mr-2">select 的缺陷</span><a href="#select-的缺陷" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>每次都需要把<code class="language-plaintext highlighter-rouge">fd_set</code>从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。<li>每次需要遍历<code class="language-plaintext highlighter-rouge">fd_set</code>的每个标志位，时间复杂度是O(n)的。<li><code class="language-plaintext highlighter-rouge">select</code>支持的文件描述符数量太小了，只有1024个。<li><code class="language-plaintext highlighter-rouge">fd_set</code>不能重用，每次都需要重置。</ol><h2 id="poll"><span class="mr-2">poll</span><a href="#poll" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="poll-api"><span class="mr-2">poll API</span><a href="#poll-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;poll.h&gt;</span><span class="cp">
</span><span class="k">struct</span> <span class="n">pollfd</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span> <span class="c1">// 委托内核检测的文件描述符</span>
    <span class="kt">short</span> <span class="n">events</span><span class="p">;</span> <span class="c1">// 委托内核检测fd的什么事件（用户设置的变量）</span>
    <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span> <span class="c1">// fd实际发生的事件（内核操作的变量）</span>
<span class="p">};</span>

<span class="cm">/* 参数介绍
fds - 是一个pollfd的结构体数组指针，这是一个需要检测的fd的集合
nfds - 表示pollfd结构体数组中最后一个有效元素的下标加1
timeout - 阻塞时长，-1表示阻塞（直到fds有变化），0表示不阻塞，大于0表示阻塞对应的时长(ms)
返回值 - -1表示失败，大于等于0表示成功，表示有对应个fd发生变化
*/</span>
<span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">pollfd</code>中的<code class="language-plaintext highlighter-rouge">events</code>和<code class="language-plaintext highlighter-rouge">revents</code>的取值有：</p><div class="table-wrapper"><table><thead><tr><th>事件<th>值<th>作为events的值<th>作为revents的值<th>说明<tbody><tr><td>读事件<td><strong>POLLIN</strong><br />POLLRDNORM<br />POLLRDBAND<br />POLLPRI<td>√<br />√<br />√<br />√<td>√<br />√<br />√<br />√<td>普通或优先带数据可读<br />普通数据可读<br />优先级带数据可读<br />高优先级数据可读<tr><td>写事件<td><strong>POLLOUT</strong><br />POLLWRNORM<br />POLLWRBAND<td>√<br />√<br />√<td>√<br />√<br />√<td>普通或优先带数据可写<br />普通数据可写<br />优先级带数据可写<tr><td>错误事件<td>POLLERR<br />POLLHUP<br />POLLNVAL<td> <td>√<br />√<br />√<td>发生错误<br />发生挂起<br />描述不是打开的文件</table></div><p>比较常用的读事件的值为<code class="language-plaintext highlighter-rouge">POLLIN</code>，写事件的值为<code class="language-plaintext highlighter-rouge">POLLOUT</code>，如果既要检测读事件也要检测写事件可以写成<code class="language-plaintext highlighter-rouge">POLLIN | POLLOUT</code>。</p><h3 id="poll使用样例"><span class="mr-2">poll使用样例</span><a href="#poll使用样例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="c1">// int lfd = socket(...);</span>
<span class="c1">// ...</span>
<span class="c1">// bind(...);</span>
<span class="c1">// listen(...);</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">FDSIZE</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

<span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="n">FDSIZE</span><span class="p">];</span> <span class="c1">// 数组大小可以任意指定，不一定是1024</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FDSIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span> <span class="c1">// 初始化pollfd结构体数组</span>
    <span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">lfd</span><span class="p">;</span> <span class="c1">// 监听fd加入数组中</span>
<span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 记录有效fd的最大下标，为了方便实现直接记录数组的最大下标即可</span>

<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
    
    <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 阻塞，等待数据进来（或等待客户端连接）</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 意外处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"poll failed"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>	
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 没有检测到fd改变</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 检测到了某些fd变化了</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">){</span> <span class="c1">// 表示监听文件描述符lfd的revents中存在POLLIN事件（位运算）</span>
            <span class="c1">// int cfd = accept(...);</span>
            
            <span class="c1">// 找pollfd数组中空闲位置插入新加入的fd（有新的客户端连接）</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FDSIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">nfds</span><span class="p">)</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 记录最大下标（不一定是有效）</span>
                <span class="k">if</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
                    <span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">cfd</span><span class="p">;</span>
                    <span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nfds</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span> <span class="c1">// 轮询fds，0是监听fd，因此需要从1开始遍历</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">){</span> <span class="c1">// 判断fds元素的revents中是否存在POLLIN事件（位运算）</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 读取失败</span>
                <span class="n">perror</span><span class="p">(</span><span class="s">"read failed"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 客户端断开连接</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"client closed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="n">close</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span><span class="p">);</span> <span class="c1">// 关闭对应fd</span>
                <span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 将pollfd数组对应元素的fd置为-1，空出位置</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 读到了数据</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// write(...); // 返回数据</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
<span class="p">}</span>
</pre></table></code></div></div><h3 id="poll的缺陷"><span class="mr-2">poll的缺陷</span><a href="#poll的缺陷" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>需要把<code class="language-plaintext highlighter-rouge">pollfd</code>数组从用户空间拷贝到内核空间，然后再从内核空间拷贝到用户空间，用户态内核态的切换造成很大的开销。<li>每次需要遍历<code class="language-plaintext highlighter-rouge">pollfd</code>数组的每个<code class="language-plaintext highlighter-rouge">revents</code>来判断是否有数据变化，时间复杂度是O(n)的。</ol><h2 id="epoll"><span class="mr-2">epoll</span><a href="#epoll" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="epoll-api"><span class="mr-2">epoll API</span><a href="#epoll-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
</span>

<span class="cm">/* struct eventpoll{
	//...
	struct rb_root rbr; // 红黑树根节点，红黑树中存储需要检测的文件描述符
	struct list_head rdlist; // 就绪队列双链表，存储有数据变化的文件描述符
	// ...
};
*/</span>

<span class="cm">/* 参数说明
size - 目前没有意义了，随便写一个大于0的数
返回值 - 失败返回-1，成功返回文件描述符fd，用于操控内核空间中的实例(eventpoll类型)
*/</span>
<span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// 在内核空间中创建实例(eventpoll类型)</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span><span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span> <span class="n">epoll_data_t</span><span class="p">;</span>
 
<span class="n">strut</span> <span class="n">epoll_event</span><span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">events</span><span class="p">;</span> <span class="c1">// 需要检测的epoll事件（EPOLL_IN、EPOLLOUT、EPOLLERR、EPOLLET等）</span>
    <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 存储用户的数据信息，一般只存fd</span>
<span class="p">};</span>

<span class="cm">/* 参数介绍
epfd - 通过epoll_create创建出来的eventpoll实例对应的fd
op - 对eventpoll实例的操作选项，比如添加fd、删除fd、修改fd检测的操作等（分别对应EPOLL_CTL_ADD、EPOLL_CTL_DEL、EPOLL_CTL_MOD）
fd - 需要进行操作的文件描述符
event - 记录了fd需要检测的事件（删除操作输入NULL即可）
返回值 - 成功返回0，失败返回-1
*/</span>
<span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span> <span class="c1">// 操作内核空间的eventpoll实例</span>

<span class="cm">/* 参数介绍
epfd - 同上
events - 存储所有发生了变化的fd
maxevents - events数组的大小
timeout - 阻塞时间，-1表示阻塞（直到有fd发生变化），0表示不阻塞，大于表示要阻塞的时长(ms)
返回值 - 成功返回发生变化的fd的个数，失败返回-1
*/</span>
<span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span> <span class="c1">// 检测是否有发生变化的fd，从内核空间的就绪队列中拷贝出来，存储在events中</span>
</pre></table></code></div></div><h3 id="epoll的两种工作模式"><span class="mr-2">epoll的两种工作模式</span><a href="#epoll的两种工作模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="水平触发level-triggered-lt"><span class="mr-2">水平触发（Level Triggered, LT）</span><a href="#水平触发level-triggered-lt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>LT是默认的工作方式，同时支持阻塞和非阻塞的socket，在这种工作模式中，<strong>内核会不断通知用户是否有文件描述符就绪了</strong>，然后用户可以对就绪的文件描述符进行IO操作，如果用户没有进行操作的话，内核还是会继续通知用户。</p><h4 id="边缘触发edge-triggered-et"><span class="mr-2">边缘触发（Edge Triggered, ET）</span><a href="#边缘触发edge-triggered-et" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>ET是较为高速的工作方式，只支持非阻塞的socket，当有文件描述符变成就绪时，<strong>内核只会通知用户一次（only once）</strong>，后续不会为这个文件描述符向用户发送就绪通知，直到用户操作了文件描述符使得这个文件描述符不再是就绪状态。</p><blockquote><p>比如有个<code class="language-plaintext highlighter-rouge">fd</code>就绪了有8个字节需要读取，用户只读取了2个字节，剩余6个字节没有读取，在下次内核发现这个<code class="language-plaintext highlighter-rouge">fd</code>里面还有数据没读的话，在ET模式下内核就不会再通知用户（直到又有新数据到来了，更改了该fd的就绪状态，但是也是会按照缓冲区的顺序读取数据），在LT模式下内核就会去通知用户。</p></blockquote><blockquote><p>ET模式减少了内核通知用户的次数，因此效率比LT模式要高，但是<code class="language-plaintext highlighter-rouge">epoll</code>在ET模式的时候，必须使用非阻塞的套接字接口，因为内核只通知用户一次，用户应该一次把数据读完，所以就不能使用阻塞的读写操作，否则就会导致进程或者线程饿死（因为需要阻塞等待数据的读或者写）。</p></blockquote><h3 id="epoll使用案例"><span class="mr-2">epoll使用案例</span><a href="#epoll使用案例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="lt模式"><span class="mr-2">LT模式</span><a href="#lt模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre><span class="c1">// int lfd = socket(...);</span>
<span class="c1">// ...</span>
<span class="c1">// bind(...);</span>
<span class="c1">// listen(...);</span>

<span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// 创建eventpoll实例，参数随便写个大于0的数</span>

<span class="c1">// 将监听fd添加到eventpoll实例中</span>
<span class="n">epoll_event</span> <span class="n">epev</span><span class="p">;</span>
<span class="n">epev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">epev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">lfd</span><span class="p">;</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">lfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epev</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">FDSIZE</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

<span class="n">epoll_event</span> <span class="n">epevs</span><span class="p">[</span><span class="n">FDSIZE</span><span class="p">];</span> <span class="c1">// 接收从内核检测到的fd集合，大小无限制</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
	
    <span class="c1">// 阻塞等待数据来（或等客户端连接）</span>
    <span class="c1">// 返回值是发生变化fd的数目</span>
    <span class="c1">// 由于是水平触发，如果数据没有读完，epoll_wait会把没有读完的fd放入就绪队列中再返回</span>
    <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">epevs</span><span class="p">,</span> <span class="n">FDSIZE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
    
    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 失败处理</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll wait failed"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rt</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
        
        <span class="kt">int</span> <span class="n">curfd</span> <span class="o">=</span> <span class="n">epevs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
		
        <span class="k">if</span><span class="p">(</span><span class="n">curfd</span> <span class="o">==</span> <span class="n">lfd</span><span class="p">){</span> <span class="c1">// 判断是否是监听fd，如果为真说明有客户端连接</span>
            <span class="c1">// ...</span>
            <span class="c1">// int cfd = accept(...);</span>
            
            <span class="c1">// 将接收到的客户端fd加入内核检测的fd集合中</span>
            <span class="n">epev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
            <span class="n">epev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">cfd</span><span class="p">;</span>
            <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epev</span><span class="p">);</span>
            
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">epevs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">){</span> <span class="c1">// 说明是客户端fd，判断是读操作的情况</span>
			<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">curfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 错误处理</span>
                <span class="n">perror</span><span class="p">(</span><span class="s">"cfd read failed"</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 客户端关闭连接</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"client closed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">curfd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">//从eventpoll实例中删除该fd</span>
                <span class="n">close</span><span class="p">(</span><span class="n">curfd</span><span class="p">);</span> 
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// 读到数据了进行对应处理</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// ...</span>
                <span class="c1">// write(...);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">epevs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">){</span> <span class="c1">//客户端fd写操作的情况</span>
            <span class="c1">// 写操作逻辑</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
       
<span class="p">}</span>
	
<span class="c1">// 关闭创建出来的lfd和epfd</span>
<span class="n">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
</pre></table></code></div></div><h4 id="et模式"><span class="mr-2">ET模式</span><a href="#et模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>相比于LT模式，ET需要多更改一些设置，代码如下：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
</pre><td class="rouge-code"><pre><span class="c1">// int lfd = socket(...);</span>
<span class="c1">// ...</span>
<span class="c1">// bind(...);</span>
<span class="c1">// listen(...);</span>

<span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> 
<span class="n">epoll_event</span> <span class="n">epev</span><span class="p">;</span>
<span class="n">epev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span> <span class="c1">// 监听fd应该为水平触发</span>
<span class="n">epev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">lfd</span><span class="p">;</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">lfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epev</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">FDSIZE</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

<span class="n">epoll_event</span> <span class="n">epevs</span><span class="p">[</span><span class="n">FDSIZE</span><span class="p">];</span> 
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
	
    <span class="c1">// 由于是边缘触发，内核只通知一次</span>
    <span class="c1">// 如果数据没读完，那么后面的数据就无法读到（需要一次性读完）</span>
    <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">epevs</span><span class="p">,</span> <span class="n">FDSIZE</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 
    
    <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> 
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll wait failed"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rt</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">){</span>
        
        <span class="kt">int</span> <span class="n">curfd</span> <span class="o">=</span> <span class="n">epevs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
		
        <span class="k">if</span><span class="p">(</span><span class="n">curfd</span> <span class="o">==</span> <span class="n">lfd</span><span class="p">){</span> 
            <span class="c1">// ...</span>
            <span class="c1">// int cfd = accept(...);</span>
            
            <span class="c1">// 设置cfd为非阻塞，以用于后续非阻塞读写</span>
            <span class="c1">// 头文件需要额外添加fcntl.h</span>
            <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">);</span> <span class="c1">// 得到cfd的flag</span>
            <span class="n">fcntl</span><span class="p">(</span><span class="n">cfd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flag</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span> <span class="c1">// 设置flag为非阻塞</span>
            
            <span class="c1">//           设置为边缘触发           //</span>
            <span class="c1">// --------------------------------//</span>
            <span class="n">epev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span> 
            <span class="c1">// --------------------------------//</span>
            
            <span class="n">epev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">cfd</span><span class="p">;</span>
            <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">cfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epev</span><span class="p">);</span>
            
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">epevs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">){</span> 
            <span class="cm">/* 无法一次性读取数据
			char buf[1024];
            memset(buf, 0, sizeof(buf));
            int len = read(curfd, buf, sizeof(buf));
            if(len == -1){ 
                perror("cfd read failed");
                exit(-1);
            }
            else if(len == 0){ 
                cout &lt;&lt; "client closed" &lt;&lt; endl;
                epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); 
                close(curfd); 
            }
            else if(len &gt; 0){ 
                cout &lt;&lt; buf &lt;&lt; endl;
                // ...
                // write(...);
            }
            */</span>
            
            <span class="c1">// 一次性读取所有数据，使用循环来分别读取出来</span>
            <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bug</span><span class="p">));</span>
            <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">curfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="c1">// 读操作逻辑</span>
                <span class="c1">// write(...) </span>
            <span class="p">}</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
				<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"clinet closed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
                <span class="c1">// 需要额外头文件errno.h</span>
                <span class="k">if</span><span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">){</span> <span class="c1">// 数据读完可能产生的错误</span>
                    <span class="c1">// 处理逻辑</span>
                <span class="p">}</span>
                <span class="k">else</span><span class="p">{</span>
                    <span class="n">perror</span><span class="p">(</span><span class="s">"read failed"</span><span class="p">);</span>
                	<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">epevs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">){</span> 
            <span class="c1">// 写操作逻辑</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
       
<span class="p">}</span>
<span class="n">close</span><span class="p">(</span><span class="n">lfd</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">epfd</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="参考资料">参考资料</h1><p>[1]. <a href="https://www.nowcoder.com/courses/cover/live/504">牛客网——C++高薪面试项目</a></p><p>[2]. <a href="https://juejin.cn/post/7036518015462015006">掘金——看一遍就理解：IO模型详解</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/'>计算机技术</a>, <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/linux/" class="post-tag no-text-decoration" >Linux</a> <a href="/tags/socket/" class="post-tag no-text-decoration" >socket</a> <a href="/tags/i-o%E6%A8%A1%E5%9E%8B/" class="post-tag no-text-decoration" >I/O模型</a> <a href="/tags/i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="post-tag no-text-decoration" >I/O多路复用</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B+-+XopowoYpa&url=%2Fposts%2FLinux%25E7%25BD%2591%25E7%25BB%259C%25E7%25BC%2596%25E7%25A8%258B%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B+-+XopowoYpa&u=%2Fposts%2FLinux%25E7%25BD%2591%25E7%25BB%259C%25E7%25BC%2596%25E7%25A8%258B%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FLinux%25E7%25BD%2591%25E7%25BB%259C%25E7%25BC%2596%25E7%25A8%258B%2F&text=Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B+-+XopowoYpa" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Linux网络编程</a><li><a href="/posts/C++11-%E6%96%B0%E7%89%B9%E6%80%A7/">C++11 新特性</a><li><a href="/posts/Redis%E5%85%A5%E9%97%A8/">Redis入门</a><li><a href="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode124.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/">Leetcode124.二叉树中的最大路径和</a><li><a href="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">Leetcode206.反转链表</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> <a class="post-tag" href="/tags/c-11/">C++11</a> <a class="post-tag" href="/tags/cmake/">CMake</a> <a class="post-tag" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a> <a class="post-tag" href="/tags/gcc/">GCC</a> <a class="post-tag" href="/tags/gdb/">GDB</a> <a class="post-tag" href="/tags/i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a> <a class="post-tag" href="/tags/i-o%E6%A8%A1%E5%9E%8B/">I/O模型</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/"><div class="card-body"> <em class="small" data-ts="1658943250" data-df="YYYY-MM-DD" > 2022-07-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++编程工具（Linux）</h3><div class="text-muted small"><p> 引言 本文主要介绍在Linux系统上C++的开发和编程所需要用到的工具，主要内容有：GCC、静态库、动态库、Makefile、GDB、CMake等主流C++编程工具。 本文持续更新中 GCC GCC全称为GNU Compiler Collection，是由GNU开发的编程语言编译器，GNU编译套件编译包括C、C++、Obeject-C、Java和Go等，也包括了这些语言的库，本文主要...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%A8%A1%E6%9D%BF%E6%96%87%E7%AB%A0/"><div class="card-body"> <em class="small" data-ts="1656321600" data-df="YYYY-MM-DD" > 2022-06-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>模板文章</h3><div class="text-muted small"><p> 一级标题 二级标题 三级标题 分割线 代码： #include&amp;lt;iostream&amp;gt; using namespace std; int main(){ cout &amp;lt;&amp;lt; &quot;Hello World!&quot;; return 0; }</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AE%97%E6%B3%95%E9%A2%98-Leetcode206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"><div class="card-body"> <em class="small" data-ts="1656337032" data-df="YYYY-MM-DD" > 2022-06-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Leetcode206.反转链表</h3><div class="text-muted small"><p> 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &amp;lt;= Node.val &amp;lt...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/C++%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7-Linux/" class="btn btn-outline-primary" prompt="上一篇"><p>C++编程工具（Linux）</p></a><div class="btn btn-outline-primary disabled" prompt="下一篇"><p>-</p></div></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">XopowoYpa</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> <a class="post-tag" href="/tags/c-11/">C++11</a> <a class="post-tag" href="/tags/cmake/">CMake</a> <a class="post-tag" href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a> <a class="post-tag" href="/tags/gcc/">GCC</a> <a class="post-tag" href="/tags/gdb/">GDB</a> <a class="post-tag" href="/tags/i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">I/O多路复用</a> <a class="post-tag" href="/tags/i-o%E6%A8%A1%E5%9E%8B/">I/O模型</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
